\documentclass{jsarticle}
\author{夕叢霧香 (Kirika Yuumura, @kirika\_comp)}
\title{整数論テクニック集 (Ver. 1.0)}

\input{./macros.tex}
\makeindex
\begin{document}
\maketitle
 \section*{はじめに}
 これは、競技プログラミングで使える整数論のテクニックをまとめた文章です。
 AtCoder の水色から赤下位程度を対象読者にしています。

 整数論の問題は知識を持っていることで解けることが多いです。
 しかし、その知識については、日本の競技プログラマーたちには、
 あまり知られていないように見えます。そのため、この文章を書くことにしました。

 基本的に、実際に出題されている問題で利用されるテクニックを、実際の問題と共に紹介するという方式で書いていきます。そのため、ネタバレは非常に多いです。ご注意ください。

 各セクションにはレベルを振ってあります。筆者が感じたおよその難易度を表しています。

 コメント等はTwitter (@kirika\_comp) までお願いします。
\tableofcontents
 \section{基本: アルゴリズムについて}
  \subsection{アルゴリズムにおける不変量}
  \label{subsec:invariant}
  アルゴリズムを考える時は、ループや再帰呼び出しのある地点で、どのような条件が常に成り立っているか、どのような値が保たれているかを考察することが、アルゴリズムの理解を助けることがあります。
  このような条件や値のことを、\emph{不変量}\index{ふへんりょう@不変量} (\emph{invariant}) と呼びます。

  例として、拡張ユークリッドの互除法と呼ばれるアルゴリズムの実装を与えます。
  拡張ユークリッドの互除法は、2個の整数 $a, b$ を入力とし、$\gcd(a, b)$ に加えて$ax + by = \gcd(a, b)$ を満たす$\tuple{x, y}$ も返すアルゴリズムです。

  以下のコードで、各再帰呼び出しの\verb+return+ 直前に$ax+by=\gcd(a,b)$ が成り立っていることに注意してください。この性質によって、最終的な返り値が $ax+by=\gcd(a,b)$ を満たすことが、つまりこのアルゴリズムが正しいことが分かります。
  \lstinputlisting[caption=extgcd.cpp,label=extgcd]{./extgcd.cpp}
 \section{$\bmod\ p$上の計算 (モジュラー演算)}
 \label{sec:mod-p-arithmetic}
  \subsection{基本: 整数の加減乗除\level{1}}
  計算結果が大きすぎるため、適当な素数 $p$ に対して$\bmod\ p$で出力せよ、という問題が結構あります。
  このような問題の場合は、最終結果を$\bmod\ p$するのではなく、途中結果も$\bmod\ p$することで、多倍長整数などを使わずに計算することができます。例えば、$abc \bmod p$ を計算したい時は、代わりに$((ab \bmod p) \times c) \bmod p$ を計算する、というようにすることができます。

  素数 $p$ については、入力として与えられる場合と、問題に固有の値が設定される場合があります。後者の場合は、$p$として$10^9 + 7$, $10^9 + 9$, $998244353$ などの値が設定されることが多いです。これらの値は、有名な素数として覚えてしまいましょう。

  なお除算については、次のサブセクションで説明する逆元を掛けることで実装することができます。
  \subsection{基本: 逆元\level{1}}
  \label{subsec:inverse-element}
  $p$を素数とします。
  $1 \le r < p$ の時、$rs \equiv 1 \pmod p, 1 \le s < p$を満たす$s$がただ一つ存在します。これを$r$の$\bmod\ p$における\emph{逆元}\index{ぎゃくげん@逆元} (\emph{inverse element})と呼びます。
  逆元の計算には、以下の2種類の方法があります:
  \begin{enumerate}
   \item $r^{p-1} \equiv 1 \pmod p$ (フェルマーの小定理、定理\ref{thm:fermats-little-theorem})を利用して、$r^{p-2} \bmod p$を計算する。
   \item 拡張ユークリッドの互除法を使う。
  \end{enumerate}
  実装が単純なのは1.ですが、多くの場合で2.の方が高速に動作します。そのうえ、2.では$p$が素数であるという条件すら不要で、$r$ と $p$ が互いに素であれば十分です。ライブラリを作る場合は、2.の方で作ると良いでしょう。

  以下に両方の実装を与えます。

  1.の実装を与えます。$a^{-1} \bmod p$ を返します。
  \lstinputlisting[caption=invmod-1.cpp,label=invmod-1.cpp]{invmod-1.cpp}

  2.の実装を与えます。$a^{-1} \bmod m$ を返します。
  \lstinputlisting[caption=invmod-2.cpp,label=invmod-2.cpp]{invmod-2.cpp}

  \subsection{基本: 分数の加減乗除\level{2}}
  \label{subsec:operations-on-fractions}
  たまに、分数についての言及があることがあります。大抵以下のような形をしています。
  \begin{center}
   答えは分数$A/B$ という形で表すことができ、$B$ は $10^9 + 7$ と互いに素であることが証明できる。このとき、$B$ の mod $(10^9+7)$ での逆元を$B^{-1}$ として、$A \times B^{-1} \bmod (10^9 + 7)$を出力せよ。
  \end{center}
  これも、特別な配慮などはせずに、途中結果をmod $(10^9+7)$ で保持しておくだけで、計算が正しく行えます。
  \begin{itembox}[l]{問題例}
   \begin{itemize}
    \item Codeforces Round \#465 (Div. 2) D. Fafa and Ancient Alphabet
   \end{itemize}
  \end{itembox}
  \begin{itembox}[l]{COLUMN}
   専門用語を使うと、これは素数 $p$ について自然に定まる環準同型$\Z \to \Z/p\Z$が、環準同型$\Z_{(p)} \to \Z/p\Z$ に拡張できる、ということができます(ただし、$\Z_{(p)}$は、$\Z$のイデアル$(p)$による\emph{局所化}と呼ばれるもので、分子が任意、分母が$p$の倍数でないような分数全体からなる環)。興味のある人は、「局所化」や「附値環」などの単語で調べてみてください。
  \end{itembox}
 \section{数表の作り方\level{1}}
 \label{sec:how-to-create-tables}
 前計算で数表を作っておき、あとで使うことが必要になる問題があります。
 このセクションでは、それらのうちよく見るものをまとめます。
  \subsection{階乗 $n! \bmod m$\level{1}}
  よく見られます。テーブルを作っていないと $O(n)$ 時間かかりますが、前計算に $O(N)$ 時間かけると $0 \le n\le N$ に対する $n! \bmod m$ が $O(1)$ 時間で計算できます。

  \lstinputlisting[caption=factorial.cpp,label=factorial.cpp]{factorial.cpp}
  \subsection{整数定数 $c$ に対する $c^n \bmod m$ \level{1}}
  よく見られます。テーブルを作っていないと $O(\log n)$ 時間かかりますが、前計算に $O(N)$ 時間かけると $0 \le n\le N$ に対する $c^n \bmod m$ が $O(1)$ 時間で計算できます。

  \lstinputlisting[caption=power.cpp,label=power.cpp]{power.cpp}
  \subsection{逆元\level{2}}
  必要な場面は少ないですが、使える場面は多いです。テーブルを作っていないと $O(\log n)$ 時間かかりますが、前計算に $O(N)$ 時間かけると $1 \le n\le N$ に対する $n^{-1} \bmod m$ が $O(1)$ 時間で計算できます。

  $N!$ と $m$ が互いに素であることが要請されます。
  例えば $m$ が素数で $0 \le N < m$ ならばこの要請は満たされます。

  \lstinputlisting[caption=inverse.cpp,label=inverse.cpp]{inverse.cpp}
  \begin{itembox}[l]{COLUMN}
   このような実装もあります。この実装では、$N$ と $m$ が互いに素であることが要請され、inv[i] の値は $i$ が $m$ と互いに素なら $i^{-1} \bmod m$ 、そうでなければ $0$ になります。
   \lstinputlisting[caption=inverse-alt.cpp,label=inverse-alt.cpp]{inverse-alt.cpp}
   この実装は\ref{inverse.cpp} の実装と、以下の点でトレードオフがあります。
    \begin{center}
     \begin{tabular}[tb]{|c|c|}
      \hline
      実装 & 軽い \\
      コードの可読性 & 低い \\
      制約 & ゆるい \\
      速度 & mod が定数の場合は比較的低速 \\ \hline
     \end{tabular}
    \end{center}

   好みや状況に応じて選びましょう。
  \end{itembox}
  \subsection{二項係数\level{1}}
  よく見られます。階乗から導出できますが、それ以外の導出方法もあるので紹介します。
  TODO
 \section{二分累乗法\level{1}}
 \label{sec:exponentiation-by-squaring}
 二分累乗法とよばれる基本テクニックがあります。

 (単位元を持ち、) 結合法則を満たす「掛け算」$x \cdot y$ が定義されているような代数的構造 (\emph{モノイド}\index{ものいど@モノイド}と呼びます) の上で、$x$ の $e$乗 $x^e = x \cdot \cdots \cdot x$は$2\log_2 e$回以内の掛け算で計算できます。この方法を\emph{二分累乗法}\index{にぶんるいじょうほう@二分累乗法} (\emph{exponentiation by squaring}) と呼びます。

 二分累乗法には2種類の方法があります。一つ目は、$e$の2進表記の小さい桁の方から計算をする方法で、もう一つは$e$ の2進表記の大きい桁の方から計算をする方法です。整数のmodつき掛け算を例にして、両方のアルゴリズムを紹介します。

 まず一つ目から紹介します。ソースコード\ref{powmod-1.cpp}に実装を載せました。
 ループの各イテレーション終了時に$prod * cur^e = (answer) = x^e$ が成立していることに注意しましょう。最終的に$e = 0$ となって $prod$ に答えが入ります。
 \lstinputlisting[caption=powmod-1.cpp,label=powmod-1.cpp]{powmod-1.cpp}

 次に二つ目を紹介します。$e$ の上の桁から見ていくアルゴリズムです。
 ループの各イテレーション終了時に$prod^{2^i} * x^{e \% 2^i} = (answer) = x^e$ が成り立つことに注意しましょう。
 \lstinputlisting[caption=powmod-2.cpp,label=powmod-2.cpp]{powmod-2.cpp}
  \subsection{モノイド的構造を見つけて二分累乗する\level{2}}
  \begin{itembox}[l]{問題}
   $\cos \theta = \frac{d}{l}$であるような$\theta$に対して、$\cos t\theta$は有理数であることが証明できる。$l\cos t\theta = \frac{p}{q}$であるとき、$pq^{-1} \bmod (10^9+7)$を求めよ。
   \begin{itemize}
    \item 部分点(15/100点): $t$は2冪である。つまり、ある0以上の整数$p$について$t=2^p$。
    \item 満点(100点): $1 \le t \le 10^{18}$, $t$は整数。
   \end{itemize}
   (出典: CodeChef February Challenge 2018 (FEB18) >> Broken Clock (BROCLK))
  \end{itembox}
  部分点解法は、2倍角の公式$\cos 2\theta = 2\cos^2\theta - 1$を利用して、$p$回の計算を行うことでできます。

  問題は満点解法の方で、愚直にやると$t$倍角の公式が必要になってきて、実質的に不可能です。そこで、ド・モアブルの公式 (de Moivre's formula)
  \begin{displaymath}
   \cos t\theta + i\sin t\theta = (\cos\theta + i\sin\theta)^t
  \end{displaymath}
  を利用して、強引に冪乗公式に持っていくことを考えましょう。
  式の形から、$\cos \theta + i\sin\theta$なる数の計算、およびそれの累乗の計算ができれば良いことになります。ここで、以下のようにペアを用いて数を表現することにします:
  \begin{displaymath}
   \tuple{a, b} \mapsto a + ib\sin \theta
  \end{displaymath}
  これにより掛け算、それゆえ冪乗が、整数ペアの上の演算として実装できます。どのようにするかみていきましょう。

  まず、$\cos\theta + i\sin\theta$はもちろん、$\tuple{\cos\theta,1}=\tuple{d/l,1}$として表現されます。掛け算についてですが、
  \begin{displaymath}
   \tuple{a, b} \times \tuple{c, d} = (a+ib\sin\theta)(c+id\sin\theta)
   =(ac-bd\sin^2\theta)+i(ad+bc)\sin\theta
   =\tuple{ac+bd(\cos^2\theta-1), ad+bc}
  \end{displaymath}
  より、問題なく実装することができます。これによりべき乗も問題なく実装でき、問題が解けます。
  \lstinputlisting[caption=BROCLK.cpp,label=BROCLK]{FEB18-BROCLK.cpp}
  \subsection{うまい変形で除算を回避する\level{2}}
  \label{subsec:avoiding-division}
  \begin{itembox}[l]{問題}
   整数$A$が、次のような10進表記で与えられる。
   \begin{displaymath}
    (A)_{10} = a_1^{L_1} \cdot a_2^{L_2} \cdot \dots \cdot a_N^{L_N}
   \end{displaymath}
   ここで、$a_i$は10進表記で与えられた整数、$L_i$は整数である。
   また$a_i^{L_i}$は、$a_i$を文字列としてみなして、$L_i$個連結したものを表し、$s \cdot t$ は文字列 $s$, $t$ の連結を表す。
   このとき、$A$を$B$で割った余りを求めよ。

   制約: $1 \le N \le 10000, 1\le a_i \le 10^9, 1 \le L_i \le 10^9$
   \begin{itemize}
    \item 部分点 (99/100点): $B = 10^9+7$。
    \item 満点 (100点): $1 \le B \le 10^9 + 7$。$B$ は素数とは限らない。
   \end{itemize}

   (出典: ARC020 C - A mod B Problem)
  \end{itembox}
  $B$が素数の場合、$A$は等比数列の総和の公式を使って、以下のような閉じた式の形で書けるので、計算することは簡単です。ここで、$b_i$は$a_i$の桁数で、
  \begin{displaymath}
   f(y,z) := 1+y+\cdots+y^{z-1} = \frac{y^z-1}{y-1}
  \end{displaymath}
  と定義します。
  \begin{displaymath}
   A = a_N f(10^{b_N},l_N)+10^{b_N \times l_N}(a_{N-1}f(10^{b_{N-1}},l_{N-1}) + 10^{b_{N-1} \times l_{N-1}} ( \ldots))
  \end{displaymath}
  問題は$B$が素数でない場合です。
  $f(y,z)$の計算の中で、$y-1$による除算を行っていますが、$y-1$と$B$が互いに素でない場合に、これは失敗します。
  これを回避するために、$y^z$を二分累乗法で計算するのを諦め、$f(y,z)$を直接二分累乗法に似た方法で計算することを考えましょう。以下の等式が成立します:
  \begin{displaymath}
   f(y,2z) = 1+y+\cdots+y^{2z-1}=(1+y+\cdots+y^{z-1})(1+y^z)=(1+y^z)f(y,z)
  \end{displaymath}
  \begin{displaymath}
   f(y,z+1)=1+y+\cdots+y^{z}=1+y(1+y+\cdots+y^{z-1})=1+yf(y,z)
  \end{displaymath}
  これによって、$z$の偶奇に応じて場合分けしながら再帰を行うことで、$f(y,z)$の値を除算なしで計算することができます。

  ソースコードは以下のようになります。\url{https://arc020.contest.atcoder.jp/submissions/2141049} です。
  \lstinputlisting[caption=ARC020C.cpp,label=ARC020C.cpp]{ARC020C.cpp}
 \section{Abundance で殴る\level{2}}
  \subsection{素数の abundance で殴る\level{2}}
  \label{subsec:abundance-of-prime-numbers}
  \begin{itembox}[l]{問題}
   正の整数 $p,y$ が与えられる。2以上$p$以下のどのような整数$i$についても$z = ki$ ($k \ge 2$) と表されないような、$y$以下の最大の整数$z$を求めよ。

   制約: $2 \le p \le y \le 10^9$

   (出典: Codeforces Round \#467 (Div. 2) B. Vile Grasshoppers)
  \end{itembox}
  まず、$z$が素数なら問題の条件は確実に満たされます。$y$付近の素数の密度は$\Theta(1/\log y)$ なので、$O(\log y)$個程度調べれば、一つは素数が見つかる計算です。与えられた$z$が問題の条件を満たすかどうかの判定は$O(\min(p, \sqrt{y}))$でできるので、$y$から大きい順に調べていくことで、時間計算量$O(\min(p, \sqrt{y})\log y)$で解くことができます。
 \section{$\bmod\ p$ のアルゴリズム}
  \subsection{基礎知識}
  \label{subsec:group-preliminaries}
   \subsubsection{フェルマーの小定理\level{1}}
   \begin{theorem}
    \label{thm:fermats-little-theorem}
    $p$が素数で$a \not \equiv 0 \pmod p$ のとき、 $a^{p-1} \equiv 1 \pmod p$が成立する。
   \end{theorem}
   \subsubsection{平方剰余\level{3}}
   \label{subsubsec:quadratic-residue}
   $a \equiv x^2 \pmod p$ となる $x$ が存在する場合、整数 $a$を$\bmod\ p$ における \emph{平方剰余}\index{へいほうじょうよ@平方剰余} (\emph{quadratic residue})、そうでない場合 $a$ を\emph{平方非剰余}\index{へいほうひじょうよ@平方非剰余} (\emph{quadratic non-residue})と呼びます。
   $p$ が奇素数の時、$1$から$p-1$までの整数の中の、平方剰余と平方非剰余の割合は1:1です。
   また、$a\not\equiv 0 \pmod p$ のとき$a^{(p-1)/2}$ は $\bmod\ p$ で $1$ か $-1$ かのどちらかと合同ですが、$a$ が平方剰余のとき$1$、平方非剰余のとき$-1$です。
   \begin{example}
    $p = 13$ の場合を考えます。このとき、$\bmod\ 13$における平方剰余のうち、0以上12以下のものは $0=0^2$,$1=1^2$,$3\equiv 4^2$,$4=2^2$,$9=3^2$,$10\equiv 6^2$,$12 \equiv 5^2 \pmod{13}$の7個です。0を除外すると1,3,4,9,10,12の6個で、1から12までの整数のうち、ちょうど半分が平方剰余、もう半分が平方非剰余です。なお、適当な平方非剰余$z$をとると、0以外の平方剰余に$z$を掛けたものはすべて平方非剰余です。例えば、$z=2$とすると、1,3,4,9,10,12に2を掛けて$\bmod\ 13$したもの(2,6,8,5,7,11)はすべて平方非剰余です。
   \end{example}
  \subsection{mod\_sqrt, Tonelli-Shanks のアルゴリズム\level{3}}
  \label{subsec:tonelli-shanks}
\subsubsection{問題}
ある $x$ について $a \equiv x^2 \pmod p$ が成り立つ $a$ が与えられる。この時、$x$ を求めよ。

\subsubsection{解法}
まず、簡単のため $p = 2$ の場合を除外します(このときは$a^2 \equiv a \pmod 2$ なので簡単)。また$a \equiv 0 \pmod p$ の場合も除外します($0^2 = 0$なので簡単)。
$p$ が$\bmod\ 4$ で3の時は簡単です。$x \equiv a^{(p+1)/4}$とすると、$x^2 \equiv a^{(p+1)/2} = a^{(p-1)/2}a \pmod p$ です。ここで、$a \equiv y^2$ となる $y$ が存在するので、$a^{(p-1)/2}\equiv y^{p-1}\equiv 1 \pmod p$ です。
だから、$x^2 \equiv a$ が成り立ちます。

$p$ が $\bmod\ 4$ で 1の時は結構複雑なことをします。ここではTonelli-Shanksの方法と呼ばれるアルゴリズムを説明します。

   \subsubsection{Tonelli-Shanks (トネリ-シャンクス) のアルゴリズム}
Reference: \url{https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm}

注意: 以下の疑似コードでは代入は全部同時に行います。特に5.で、$t$に代入する値は前の $c$ によって決まります。

注意2: 本来の Tonelli-Shanks とは違いますが、不変量を考えることで筆者が復元できたのが以下のアルゴリズムなので、こちらの方が理解しやすいと思います。(効率は悪い)

\begin{algorithm}                      
\caption{単純化された Tonelli-Shanks のアルゴリズム}
\label{alg:simplified-tonelli-shanks}
入力: $p (\ge 3)$: 奇素数, $a (\not \equiv 0 \pmod p)$: 平方剰余

出力: $r^2 \equiv a \pmod p$, $1 \le r \le p - 1$ を満たす整数 $r$

$p = q \times 2^s + 1$ とします。 ($s \ge 1$, $q$は奇数)

1. $z^{(p-1)/2} \equiv -1 \pmod p$ となるような $z$ を選ぶ。このような $z$ は確率1/2でヒットするため、何個か試せば必ず見つかる。

2. $m := s, c:\equiv z^q, t :\equiv a^q, r :\equiv a^{(q + 1)/2}$ とする。以降不変量 $\bm{r^2\equiv at \pmod p, t^{2^{m - 1}} \equiv 1 \pmod p, c^{2^{m-1}} \equiv -1 \pmod p}$ を崩さないように注意して操作する。

3. 以降 $m$ を減らしていく。$m$ が1なら終了し、$r \bmod p$ を返す。そうでなければ、$t^{2^{m-2}} \equiv 1 \pmod p$ なら4.へ、そうでなければ5.へ行く。

4. $c :\equiv c^2 \pmod p, m := m - 1$, 6.へ行く。

5. $c :\equiv c^2 \pmod p, t :\equiv c^2 t \pmod p, r :\equiv cr \pmod p, m := m - 1$ を\emph{全て同時に}代入する, 6.へ行く。

6. 3.へ行く。

\end{algorithm}
終了時には$m=1$なので、$t\equiv 1 \pmod p$になっているはずで、そのときの $r$ が求める値です。(不変量 $r^2\equiv at \pmod p$ に注意。)



C++での実装はソースコード\ref{alg:tonell-shanks}のようになります。
\lstinputlisting[caption=tonelli-shanks.cpp,label=alg:tonell-shanks]{tonelli-shanks.cpp}

例を挙げて見ていきましょう。
$p = 41$, $a = 8$ とします。

$p = 5 * 2^3 + 1$ なので、$q = 5, s = 3$ です。
$z$ として、ここでは 7 をとります。

$m := 3, c :\equiv 7^5 = 16807 \equiv 38, t :\equiv 8^5 = 32768 \equiv 9, r \equiv 8^3 = 512 \equiv 20$ となります。 ($\bmod\ 41$ は適宜省略)

 \begin{table}[htb]
  \begin{center}
  \begin{tabular}[t]{|c|c|c|c|}
   \hline
   $m$ & $c$ & $t$ & $r$ \\ \hline
   3 & 38 & 9 & 20 \\
   2 & 9 & 40 & 22 \\
   1 & 40 & 1 & 34 \\ \hline
  \end{tabular}
  \end{center}
 \end{table}


よって、$x \equiv \pm 34 (\equiv \mp 7)$ が答えになります。


以上のアルゴリズムには、4.のパートに無駄があります。4.では$c$と$m$しか変更していないので、$t^{2^i}\not \equiv 1 \pmod p$ となる最大の $i$ が見つけられれば、4.の操作をまとめることができます。このアイデアを使うのが、本来の Tonelli-Shanks のアルゴリズム (Algorithm~\ref{alg:tonelli-shanks}) です。

  \begin{algorithm}                      
   \caption{Tonelli-Shanks のアルゴリズム}
   \label{alg:tonelli-shanks}
   入力: $p (\ge 3)$: 奇素数, $a (\not \equiv 0 \pmod p)$: 平方剰余

   出力: $r^2 \equiv a \pmod p$ を満たす$r$

   $p = q \times 2^s + 1$ とします。 ($s \ge 1$, $q$は奇数)

   1. $z^{(p-1)/2} \equiv -1 \pmod p$ となるような $z$ を選ぶ。このような $z$ は確率1/2でヒットするため、何個か試せば必ず見つかる。

   2. $m := s, c:\equiv z^q, t :\equiv a^q, r :\equiv a^{(q + 1)/2}$ とする。以降不変量 $\bm{r^2\equiv at \pmod p, t^{2^{m - 1}} \equiv 1 \pmod p, c^{2^{m-1}} \equiv -1 \pmod p}$ を崩さないように注意して操作する。

   3. 以降 $m$ を減らしていく。$m$ が1なら終了。そうでなければ、$t^{2^k} \equiv 1 \pmod p$ となるような最小の整数 $k$ を求める。これは二分累乗法でできる。この $k$ は $1 \le k \le m - 1$ を満たす。

   4. $c :\equiv c^{2^{m - k}} \pmod p, t :\equiv c^{2^{m - k}} t \pmod p, r :\equiv c^{2^{m - k - 1}}r \pmod p, m := k$ を\emph{全て同時に}代入する, 3.へ行く。
  \end{algorithm}

 以上を使うと、次の問題が解けます。

 \begin{itembox}[l]{問題}
  相異なることが保証されている$n$ 個の整数 $a_1, \ldots, a_n$ が与えられる。これを並べ替えて、$x \bmod m, (x + d) \bmod m, \ldots, (x +(n - 1)d) \bmod m$ と表せるかどうか判定せよ。表せる場合、$x, d$ ($0 \le x < m, 0 \le d < m$ を満たす) を復元せよ (複数ある場合はどれでもよい)。表せない場合、 $-1$ を出力せよ。

  制約: $2 \le m \le 10^9 + 7$、$m$ は素数、$1 \le n \le 10^5$, $0 \le a_i < m$

  (出典: Codeforces Round \#395 (Div. 1) C. Timofey and remoduling)
 \end{itembox}
 並べ替えても平均と分散は変わらないため、これを特徴量とすることができます。
 平均は$x + d(n - 1) / 2$, 分散は$(n-1)(n+1)d^2/12$です。($m \neq 2, 3$ かつ $n \neq 1, m-1,m$ ならば) ここから$d$が復元でき、$x$も復元できます。最後に復元した$x, d$が妥当か調べれば OK です。

 $m = 2, 3$ の場合は全探索でよいでしょう。$a_i$たちは相異なるので、$n \le m$ であることに注意しましょう。
 また$n = 1, m-1$の場合はそれぞれ$d = 0, 1$とするとよく、$n = m$ の場合は$\tuple{x, d} = \tuple{0, 1}$ が常に正答を与えます。

 ソースコードは以下の通りです。\url{http://codeforces.com/contest/763/submission/35830261} です。
 \lstinputlisting[caption=CF395-1C.cpp,label=CF395-1C.cpp]{CF395-1C.cpp}

\begin{itembox}[l]{COLUMN}
 群論的なアプローチをすると、Algorithm~\ref{alg:simplified-tonelli-shanks} についてもっと綺麗な見方が得られます。
$(\Z/p\Z)^* \cong \Z/(p-1)\Z \cong (\Z/2^s\Z) \times (\Z/q\Z)$ の2冪成分(2-Sylow部分群\index{Sylowぶぶんぐん@Sylow部分群}) $H \cong \Z/2^s\Z$ を考えます。このとき、$z$ と $t$ は $H$ の元であることがわかります。$t$が$1$になるように、うまく$H^2 := \{h^2 \mid h \in H\}$の元で調整しているわけです。

 このあたりの話題は、この後のセクション\ref{sec:group-theory} で詳しく紹介します。
\end{itembox}
 \section{群論\level{4}}
 \label{sec:group-theory}
  \subsection{群\level{4}}
  結合法則を満たす乗算と、乗算の逆元と、乗算の単位元が定義された集合のことを\defineRuby{群}{ぐん} (\emph{group}) と呼びます。例えば、整数全体の集合$\Z$ や、有理数全体の集合$\Q$ は、加法を演算とした群です。
  $n$ 要素の置換全体の集合は $n!$ 個の要素を持ちますが、この集合は置換の合成を演算として群をなします。この群を\defineRuby{対称群}{たいしょうぐん} (\emph{symmetric group}) と呼び、$S_n$ と表記します。また、$n$を正の整数として、可逆な$n$次実数係数行列全体は、行列積という演算で群をなします。

  群の演算は、交換法則$a * b = b * a$ を満たさなくても構いません。満たす場合、その群は\defineRuby{アーベル群 (可換群)}{あーべるぐん} (\emph{abelian group (commutative group)}) と呼ばれます。$\Z$ や $\Q$ はアーベル群の例です。3次以上の対称群や、$n \ge 2$ のときの$n$次可逆実数係数行列全体の群は、アーベル群でない群の例です。

   群 $G$ の部分集合であって、$G$ の演算でまた群となるものを、$G$ の\defineRuby{部分群}{ぶぶんぐん} (\emph{subgroup}) と呼びます。たとえば、偶数だけを集めた集合 $2\Z := \{2x \mid x \in \Z\}$ に加法という演算を入れた群は、 $\Z$ の部分群です。
   \subsubsection{巡回群\level{4}}
   $G$ が \defineRuby{巡回群}{じゅんかいぐん} (\emph{cyclic group})であるとは、ある要素$g \in G$ が存在して、任意の要素 $x \in G$ が $x = g^i = g \cdot g \cdot \cdots \cdot g$ の形で表せることをいいます。この $g$ のことを\defineRuby{生成元}{せいせいげん} (\emph{generator}) と呼びます。
   整数$m$ に対して、整数を$m$で割った余り全体の集合を$\Z/m\Z$と書きます。$\Z/m\Z$ は、加法を演算として、群の構造を持ちます。これは巡回群の一例となっています。
   これ以降、$\Z/m\Z$ の元の演算については、合同式の $\equiv$ と $\pmod m$ を適宜省略します。たとえば、
   \begin{displaymath}
    x = 4 \in \Z/10\Z, y = 7 \in \Z/10\Z \mbox{のとき、} x + y = 1
   \end{displaymath}
   などという数式を書くことがあります。
   \subsubsection{乗法群\level{4}}
   $\Z/m\Z$ の要素のうち、$m$と互いに素な元には乗法の逆元が存在することは、\ref{subsec:inverse-element}で確かめました。これらの元からなる集合を$(\Z/m\Z)^*$ と表記し、$\Z/m\Z$の\emph{乗法群} \index{じょうほうぐん@乗法群} (\emph{multiplicative group}) と呼びます。例えば、$(\Z/7\Z)^* = \{1,2,3,4,5,6\}, (\Z/10\Z)^* = \{1,3,7,9\}$ です。
   これの演算についても、今後は $\equiv$ と $\pmod m$は適宜省略します。たとえば、$(\Z/7\Z)^*$ において$3^4 = 81 = 4$ である、というようにです。

   $m$が素数$p$のとき、$(\Z/p\Z)^*$ は巡回群であることが知られています。\footnote{$(\Z/m\Z)^*$が巡回群となる 2以上の整数$m$ は、$m = 2, 4, p^e, 2p^e$ ($p$ は奇素数、$e$は正の整数) の形に限られることが知られています。} $(\Z/p\Z)^*$ の生成元のことを、$\bmod\ p$ における\defineRuby{原始根}{げんしこん} (\emph{primitive root}) と呼びます。
   例えば、$(\Z/7\Z)^*=\{1,2,3,4,5,6\}$ について、$3^0=1,3^1=3,3^2=2,3^3=6,3^4=4,3^5=5$ であるため、$3$はmod 7 における原始根です。

   ここで、1から$p-1$までの整数の中の$\bmod\ p$の平方剰余全体の集合を、$H$と書くことにして、$H$ の群論的性質を見てみましょう。$H$は $(\Z/p\Z)^*$ の部分群です。
   \ref{subsubsec:quadratic-residue} でみたように、平方非剰余$z \not \in H$を適当にとると、$zH := \{zh \mid h \in H\}$と$H$は共通部分を持たず、また$|H| = |zH|$, $H \cup zH = (\Z/p\Z)^*$ です。このように、群論では、部分群を用いた類別が綺麗に成功し、要素を性質によって等分することができる場合があります。この場合、1から$p-1$までの整数の中に、平方剰余と平方非剰余が同じ個数だけ存在することが、このように表現できます。
 \section{平方剰余の相互法則と2次体\level{4}}
  \subsection{ルジャンドル記号}
  \label{subsec:legendre-symbol}
  ルジャンドル記号\index{るじゃんどるきごう@ルジャンドル記号}とは、以下で定義されるものです。
  \begin{displaymath}
   \legendre{a}{p} := \begin{cases}
		      1 & \mbox{$a$が平方剰余のとき} \\
		      -1 & \mbox{$a$が平方非剰余のとき}\\
		      0 & \mbox{$a \equiv 0 \pmod p$のとき}
		     \end{cases}
  \end{displaymath}

  \begin{proposition}
   \begin{displaymath}
     \legendre{a}{p} \equiv a^{\frac{p-1}{2}} \pmod p
    \end{displaymath}
  \end{proposition}
  \begin{proposition}
   \label{prop:legendre-symbol-is-multiplicative}
   ルジャンドル記号は乗法的である。つまり、
   \begin{displaymath}
    \legendre{a}{p} \legendre{b}{p} = \legendre{ab}{p}
   \end{displaymath}
  \end{proposition}
  \begin{corollary}
   対応 $a \mapsto \legendre{a}{p}$ は群準同型$(\Z/p\Z)^* \to \{+1,-1\}$ を定める。
  \end{corollary}
  \subsection{平方剰余の相互法則}
  以下の定理が成り立つことが知られています。
  \begin{theorem}[平方剰余の相互法則]
   $p, q \ge 3$ を奇素数とする。このとき、以下が成立する。
   \begin{displaymath}
    \left(\frac{p}{q}\right)\left(\frac{q}{p}\right) = (-1)^{\frac{p-1}{2} \times \frac{q-1}{2}}
   \end{displaymath}
  \end{theorem}
  \begin{theorem}[補充法則]
   $p \ge 3$ を奇素数とする。このとき、以下が成立する。
   \begin{displaymath}
    \legendre{-1}{p} = (-1)^{\frac{p-1}{2}},
    \legendre{2}{p} = (-1)^{\frac{p^2-1}{8}}
   \end{displaymath}
  \end{theorem}
  これを利用することで、ルジャンドル記号を計算できます。
  \begin{example}
   \label{ex:legendre-3}
   $p \neq 2,3$を、2,3以外の素数とします。このとき、
   $\legendre{3}{p}$ は、$p$ を12で割った余りで完全に決まります。
   \begin{displaymath}
    \legendre{3}{p} = (-1)^{\frac{p-1}{2}}\legendre{p}{3}
   \end{displaymath}
   ここで、
   \begin{displaymath}
    \legendre{p}{3} = \begin{cases}
		       1 & \mbox{if }p\equiv 1 \pmod 3 \\
		       -1 & \mbox{if }p\equiv 2 \pmod 3
		      \end{cases}
   \end{displaymath}
   なので、
   \begin{displaymath}
    (-1)^{\frac{p-1}{2}} = \begin{cases}
			    1 & \mbox{if }p \equiv 1 \pmod 4 \\
			    -1 & \mbox{if }p \equiv 3 \pmod 4
			   \end{cases}
   \end{displaymath}
   と合わせ、
   \begin{displaymath}
    \legendre{3}{p} = \begin{cases}
		       1 & \mbox{if }p\equiv 1,11 \pmod{12} \\
		       -1 & \mbox{if }p\equiv 5,7 \pmod{12}
		      \end{cases}
   \end{displaymath}
   が得られます。
  \end{example}
  \subsection{2次体}
  \label{subsec:quadratic-field}
  体$K$に、$\theta \not \in K$ なる要素$\theta$ を追加することを、$\theta$ を\defineRuby{添加}{てんか}するといい、そうしてできた体を$K(\theta)$ と表記します。
  有理数体 $\Q$ に、平方数でない整数 $d$ の平方根 $\sqrt{d}$を添加した体 $\Q(\sqrt{d})$ を、\emph{2次体}\index{にじたい@2次体} (\emph{quadratic field})と呼びます。
  2次体は古くから性質が研究されていて、理論も深いものがあります。このセクションおよびこの記事の後の方では、競技プログラミングに関連する部分を、主に取り上げたいと思います。
  \subsection{有限体}
  任意の素数$p$と正の整数$e$に対して、$p^e$要素の有限体が存在します。逆に、有限体の要素数は、必ず$p^e$ の形で表せます。このような有限体は、一意に存在します。これを$\finiteField{p^e}$と表記することにします。

  $\finiteField{p^e}$ は、$\finiteField{p}$ にある要素を添加することで得ることができます。つまり、ある要素$\theta$に対して、$\finiteField{p^e} \cong \finiteField{p}(\theta)$ です。
  \subsection{フロベニウス写像}
  $\Frob \colon \finiteField{p^e} \to \finiteField{p^e}, \Frob(x) := x^p$ を\emph{フロベニウス写像}\index{ふろべにうすしゃぞう@フロベニウス写像}と呼びます。
  \begin{proposition}
   $\Frob$は$e$回適用すると元に戻る。つまり、$\Frob^e(x) = x$。
  \end{proposition}
  \begin{proof}
   $\finiteField{p^e}$の元 $x\in \finiteField{p^e}$ は、すべて$x^{p^e}=x$を満たすことから、明らかです。
  \end{proof}
  \begin{proposition}
   $x, \Frob(x), \Frob^2(x), \ldots, \Frob^{e-1}(x)$ は全て\defineRuby{共役}{きょうやく}。つまり、ある$\finiteField{p}$ 係数の$e$次多項式$f(t)$が存在して、$x, \Frob(x), \Frob^2(x), \ldots, \Frob^{e-1}(x)$ はすべて $f(t)=0$ の根である。
  \end{proposition}
  \subsection{応用例}
  \label{subsec:application-of-frobenius}
  \begin{itembox}[l]{問題}
   数列 $a_0 = 2, a_{n+1} = a_n(a_n+4)$がある。このとき、素数$M$に対して、$a_N \bmod M$ を求めよ。

   (出典: yukicoder No.613 Solitude by the window)
  \end{itembox}
  この問題は、一般項を求めるところが一番難しく、一般項を求めた後は数論的な考察を進めるだけで解けます。
  ここでは、$a_n = (2+\sqrt{3})^{2^n} + (2-\sqrt{3})^{2^n} - 2$ であることがわかっているとして、この状態から問題を解いてみましょう。$a_n \bmod M$が計算できれば良いです。

  $(2+\sqrt{3})^{2^n} \bmod M$が計算できれば万事解決です。
  簡単のため、$M$が2でも3でもないとしましょう。3が$\bmod\ M$で平方剰余なら(つまり$\legendre{3}{M}=1$なら)、議論は$\finiteField{M}$の中で完結できます。
  3が$\bmod\ M$で平方非剰余(つまり$\legendre{3}{M}=-1$)の場合を考えます。
  このとき、$\finiteField{M}$に$\sqrt{3}$を添加して拡大したものは、$\finiteField{M^2}$と同型になります。
  \begin{displaymath}
   \finiteField{M}(\sqrt{3}) \cong \finiteField{M^2}
  \end{displaymath}
  ここで、$\Frob(2+\sqrt{3}) = (2+\sqrt{3})^M \in \finiteField{M^2}$がどのような元になるかを考えてみましょう。$2+\sqrt{3}$の共役は自分自身と$2-\sqrt{3}$のみなので、$\Frob(2+\sqrt{3})=2-\sqrt{3}$でなければなりません。これから、$(2+\sqrt{3})^{M+1}=(2-\sqrt{3})(2+\sqrt{3})=1$であることが分かります。

  よって、$M \equiv 1, 11 \pmod{12}$なら周期$M-1$、それ以外なら周期$M + 1$だと思って実装することができます。注意すべきなのは$M = 2,3$のケースで、今回は周期が$M \pm 1$のどちらだと思っても偶然うまく動作しますが、うまく行かない問題もあるので、注意が必要です。

  この問題は筆者が writer でした。ソースコードを以下に載せます。\url{https://yukicoder.me/submissions/239504} からアクセスすることもできます。 (今回限り Java です。)
  \lstinputlisting[caption=yukicoder-613.java,label=yukicoder-613.java,language=Java]{yukicoder-613.java}
 \section{$\bmod\ p$ のアルゴリズム その2}
 \label{sec:mod-p-2}
  \subsection{mod\_sqrt その2, Lehmer のアルゴリズム\level{3}}
  \label{subsec:karp-mod-sqrt}
  \begin{theorem}
   \label{thm:quadratic-residue-fermat}
   $p$ を奇素数とする。
   $\bmod\ p$の0以外の平方剰余を$a_1, \ldots, a_{\frac{p-1}{2}}$ とする。
   このとき
   \begin{displaymath}
    (x - a_1) \times (x - a_2) \times \cdots \times (x - a_{\frac{p-1}{2}})
    \equiv x^{\frac{p-1}{2}}-1 \pmod p
   \end{displaymath}
   が成り立つ。
  \end{theorem}
  \begin{proof}
   定理\ref{thm:polynomial-fermat} と同じ論法が使えます。
  \end{proof}
  これを利用したアルゴリズム (Algorithm~\ref{alg:lehmer-mod-sqrt}) を紹介します。このアルゴリズムは Lehmer によるものです。

  \begin{algorithm}
   \caption{\cite[Algorithm~3.1]{Karp1991}}
   \label{alg:lehmer-mod-sqrt}
   入力: $p$: 奇素数, $a$: $1 \le a < p$ を満たす平方剰余

   出力: $r^2 = a$ を満たす$r$

   1. $c \in \Z/p\Z$ をランダムに選び、$\legendre{c^2-a}{p} = -1$となるようにする。

   2. 多項式 ($\finiteField{p}[x]$ の元) の最大公約数 $\gcd(x^{\frac{p-1}{2}} - 1, (x-c)^2 - a)$ を計算する。答えは1次式 $ux + v$ となる。$a$ の平方根は$\pm (c + u^{-1}v)$ なので、$+$ か $-$ のうちどちらかを出力する。
  \end{algorithm}

  1.での選択にかかる時間の期待値が定数で抑えられることは、以下の定理で証明できます。
  \begin{theorem}[{\cite[Theorem~3.2]{Karp1991}}]
   \label{thm:abundance-of-witnesses-in-karp1991}
   $p$ を奇素数、$a \in (\Z/p\Z)^*$ を平方剰余とする。このとき、$c \in \Z/p\Z$ が一様にランダムに選ばれるならば、確率$(p-1)/2p$で$\legendre{c^2-a}{p} = -1$ が成立する。
  \end{theorem}
  \begin{proof}
   まず、$x^2 - y^2 = a$ を満たす$\tuple{x, y} \in (\Z/p\Z)^2$の個数を計算しましょう。
   以下の事実に着目します。
   \begin{center}
    $G := \{\tuple{x, y, a} \in (\Z/p\Z)^2 \times (\Z/p\Z)^* \mid x^2 - y^2 = a \}$ としたとき、$G$には以下により群構造が入る。
    \begin{align*}
     e &:= \tuple{1, 0, 1},\\
     \tuple{x, y, a} * \tuple{z, w, b} &:= \tuple{xz + yw, xw+yz, ab},\\
     \tuple{x, y, a}^{-1} &:= \tuple{xa^{-1}, -ya^{-1}, a^{-1}}
    \end{align*}
   \end{center}
   任意の$a \in (\Z/p\Z)^*$に対して、$x^2-y^2=a$となる$\tuple{x,y}\in (\Z/p\Z)^2$ が存在します。これは、$a$が平方剰余の場合は自明で、$a$が最大の平方非剰余の場合は$a+1$が平方剰余であることから$(\sqrt{a+1})^2-1^2=a$とすればよく、$a$がそれ以外の平方非剰余の場合は、$G$の群構造を利用すれば良いことからわかります。

   また、このような$\tuple{x,y}$の個数は$a$に依存しません。適当に$\tuple{u,v,a}\in G$となるような$u,v$を選ぶことで、全単射$\{\tuple{x, y} \mid \tuple{x,y,1} \in G \} \to \{\tuple{x, y} \mid \tuple{x, y, a} \in G\}$が掛け算として構成できるからです。
   以上から、各$a \in (\Z/p\Z)^*$ に対して、$x^2 - y^2 = a$ を満たす$\tuple{x,y} \in (\Z/p\Z)^2$の個数が$|G|/(p-1)$であることが分かりました。$|G|$ を計算します。

   $x^2-y^2 = 0$ を満たす$\tuple{x,y}$は何個存在するでしょうか? $x = 0$ ならば $y = 0$ で、
   $x \neq 0$ ならば、$y$ は $y = \pm x$ の2個存在するので、合計 $(2p-1)$ 個です。よって、$|G| = p^2 - (2p - 1) = (p - 1)^2$ が成り立ちます。

   以上から、$a \in (\Z/p\Z)^*$ を固定したとき、$x^2-y^2=a$ を満たす $\tuple{x,y}$ はちょうど $(p - 1)$ 個存在することが分かりました。求めたいものは、$a$ が平方剰余であることを仮定した場合の、$x^2-y^2=a$ を満たす $y$ が存在しないような $x$ の個数です。$x = \pm \sqrt{a}$ のときは $y = 0$ が条件を満たします。$x$ がそれ以外の場合は、条件を満たす$y$は存在しないか2個存在するかのいずれかです。よって、$y$が存在しないような$x$の個数は、$p - 2 - (p - 1 - 2)/2 = (p - 1)/2$ 個であることが分かりました。

   よって、問題の確率は$(p-1)/2p$です。
  \end{proof}
  また、このアルゴリズムの正当性については、以下のような観察により証明できます。

  まず、$a$ は平方剰余なので、$r^2 \equiv a \pmod p$ となるような$r$が存在します。
  このような$r$ について、$(x-c)^2-a = (x - c -r) (x - c + r)$ です。
  先ほどみたように$\legendre{c^2-a}{p} = -1$ で、命題\ref{prop:legendre-symbol-is-multiplicative} より$\legendre{c + r}{p}\legendre{c - r}{p} = -1$ です。
  そのため、$\legendre{c + r}{p}$ か $\legendre{c - r}{p}$ のどちらかは1でどちらかは$-1$となります。定理\ref{thm:quadratic-residue-fermat}より、$x^{\frac{p-1}{2}}-1$ は全ての平方剰余$a$に対する$x-a$の積です。よって、$(x - c -r) (x - c + r)$ と $x^{\frac{p-1}{2}}-1$ の最大公約数をとると、$c\pm r$ のうち平方剰余の方だけが残ります。残った方が$-u^{-1}v$ なので、$c \pm r = -u^{-1}v$ を解いて $r = \mp (c + u^{-1}v)$ です。

  このアルゴリズムの計算量についてですが、$r(x) = (x^{\frac{p-1}{2}} - 1) \bmod ((x-c)^2 - a)$ と置くと、$r(x)$ が求めたい最大公約数であることは明らかです。これは二分累乗法を用いることで $O(\log p)$ で計算できます。よって、このアルゴリズムの計算量は、$O(\log p)$です。

  実装を以下に載せます。
  \lstinputlisting[caption=lehmer.cpp,label=lehmer.cpp]{lehmer.cpp}
  \subsection{mod\_sqrt その3, Cipolla のアルゴリズム\level{4}}
  Cipolla のアルゴリズムと呼ばれるものを紹介します。\url{http://pekempey.hatenablog.com/entry/2017/02/03/220150} でも紹介されています。

  \begin{algorithm}
   \caption{Cipolla のアルゴリズム}
   \label{alg:cipolla-mod-sqrt}
   入力: $p$: 奇素数, $a$: $1 \le a < p$ を満たす平方剰余

   出力: $r^2 = a$ を満たす$r$

   1. $c \in \Z/p\Z$ をランダムに選び、$\legendre{c^2-a}{p} = -1$となるようにする。

   2. $\theta = \sqrt{c^2-a}$ として体拡大$\finiteField{p}(\theta)$ を考える。
   $(c + \theta)^{\frac{p+1}{2}}$ は $\finiteField{p}$ の元であり、これが答え (平方根の一つ) を与える。
  \end{algorithm}

  \begin{proposition}
   \label{prop:cipolla-mod-sqrt-is-correct}
   Algorithm~\ref{alg:cipolla-mod-sqrt}は正しい解を与える。
  \end{proposition}
  \begin{proof}
   Algorithm~\ref{alg:lehmer-mod-sqrt} と同様に、1.にかかる時間の期待値は、定数で抑えることができます。

   2.について調べましょう。\ref{subsec:application-of-frobenius} でみたように、$(c+\theta)^{p} = c - \theta$ となることが示せます。よって$(c+\theta)^{p+1} = c^2-\theta^2 = a$ です。
   よって$(c+\theta)^{\frac{p+1}2} \in \finiteField{p}$ が示せれば良いです。

   より一般に$(x+y\theta)^2 = a$ ならば$y = 0$ を示します。
   $(x+y\theta)^2 = (x^2+(c^2-a)y^2) + 2xy\theta$ であり、$1$ と $\theta$ が$\finiteField{p}$ 上線形独立であることから、$2xy = 0$ であることがわかります。$p$は奇素数なので、$x=0$ あるいは $y=0$ が成り立ちます。ここで$x = 0$, $y \neq 0$ だとしましょう。このとき$a = (y\theta)^2 = (c^2-a)y^2$ ですが、$c^2-a$ が平方非剰余となるように$c$を選んだので、矛盾します。
  \end{proof}
  \begin{remark}
   あるいは、これは単に、$\finiteField{p}(\theta)$が体であるため、方程式 $x^2-a = 0$は$\finiteField{p}(\theta)$上に根を最大2個しか持たず、$a$が平方剰余であるためそれらは$\finiteField{p}$の元であるような2個だけである、ということもできます。
  \end{remark}
  このアルゴリズムの計算量は、冪乗を何回か計算するだけなので、$O(\log p)$ です。

  実装を与えます。
  \lstinputlisting[caption=cipolla.cpp,label=cipolla.cpp]{cipolla.cpp}
  \begin{remark}
   このアルゴリズムに、$a$ として平方非剰余を与えると、命題\ref{prop:cipolla-mod-sqrt-is-correct}の証明中の議論で、$y=0$ではなく$x=0$が成立します。よって、ソースコード\ref{cipolla.cpp}の実装では、常に0が返ることになります。
  \end{remark}
 \section{多項式を使うテク~\level{4}}
 \label{sec:technique-using-polynomials}
  \subsection{高速フーリエ変換 (FFT)~\level{3}}
  \label{subsec:fft}
  数列$a_0, a_1, \ldots, a_{n-1}$ と $b_0, b_1, \ldots, b_{n-1}$に対して、$a$ と $b$ の\emph{畳み込み}\index{たたみこみ@畳み込み} (\emph{convolution}) とは、数列$c_i := \sum_{(j+k)\%n=i} a_{j}b_{k}$ ($0 \le i \le n - 1$) のことです。多項式の積の係数も、畳み込みだと思うことができます。

  \emph{高速フーリエ変換} (\emph{fast Fourier transform}, FFT) という手法を使うことで、$d$項の数列の畳み込みの計算量が$O(d^2)$から$O(d \log d)$になります。よって、$d$次多項式の乗算も、同じ計算量でできます。
  詳しくは、\url{https://atc001.contest.atcoder.jp/tasks/fft_c} を参考にしてください。

  doubleで計算を行うと誤差が出るので、次数$d$, 係数の最大値$u$として、$du^2 \le 10^{15}$くらいでないと整数演算のためには使えません。
  理由は、畳み込みの結果の係数は最大$du^2$程度で、整数として扱うため double の精度の関係で $du^2 < 2^{53}$でないといけないからです。$d \le 10^5, u\le 10^5$くらいでギリギリでしょう。

  実装を載せます。
  \lstinputlisting[caption=fft.cpp,label=fft.cpp]{fft.cpp}

  \begin{itembox}[l]{COLUMN}
   NTT (number theoretic transformation) (FMT (fast modulo transformation) ともいう) という手法があります。これは、doubleの代わりに Proth prime $p = k \times 2^n + 1$ をmodとした環の上でFFTをするという手法です。
   整数演算なので誤差が出ないのが嬉しいです。その上、doubleの上で行うFFTと比べてもパフォーマンスに大きな違いはありません。
   詳しくは\url{http://math314.hateblo.jp/entry/2015/05/07/014908} を見てください。
   サブセクション\ref{subsec:mod-convolution} でも少し触れます。
  \end{itembox}
  \subsection{フェルマーの小定理~\level{3}}
  \begin{theorem}
   \label{thm:polynomial-fermat}
   素数$p$に対して、以下の等式が成り立つ:
   \begin{displaymath}
    (x+1) \times (x+2) \times \cdots \times (x + (p - 1)) \equiv x^{p-1} - 1 \pmod p
   \end{displaymath}
  \end{theorem}
  \begin{proof}
  まず、$(x+k)$同士は互いに素です。フェルマーの小定理から、$1 \le k \le p - 1$なる各$k$について、$x + k | x^{p-1} - 1$が成り立ちます(整除は$\finiteField{p}[x]$の上のもの)。以上より、$(x+1) \times (x+2) \times \cdots \times (x + (p - 1)) | x^{p-1}-1$です。この整除関係の左辺も右辺も$(p-1)$次なので、両者は定数倍の違いしかありません。$x^{p-1}$の係数を比べることで、その定数倍は1倍である、つまり両者が等しいことがわかります。
  \end{proof}
  \begin{remark}
   $p$が素数でない場合にこれを拡張しようとしても、失敗します。例えば$p=8$の時、$(x+1)(x+3)(x+5)(x+7) \equiv x^4 + 6x^2 + 1 \not \equiv x^{\varphi(8)}-1 \pmod 8$です。これは、$x+k$が$(\Z/p\Z)[x]$の既約元であっても素元ではないことに由来します。\footnote{可換環$R$があるとき、$a \in R$が\defineRuby{既約元}{きやくげん} (\emph{irreducible element}) であるとは、$b\in R, c\in R, a = bc$ となる場合$b$ または $c$ のどちらかが\defineRuby{可逆元}{かぎゃくげん} (\emph{invertible element}) (逆数が$R$の元である) となることです。また、$a$が\defineRuby{素元}{そげん} (\emph{prime element}) であるとは、$a | xy$ となる場合、$a | x$ または $a | y$ のどちらかが成立することです。可換環$R$ が体なら$R[x]$は既約元が全部素元になりますが、$R$が体でない場合それは保証されません。$p$が素数でない場合、$\Z/p\Z$は体ではありません。}
  \end{remark}

  この事実を応用して解ける問題を紹介します。以下の問題を考えましょう。
  \begin{itembox}[l]{問題}
   正の整数$n$と素数$p$が与えられる。$[n] := \{1,\ldots, n\}$ として、整数$k$に対して$f(n, k)$ を以下で定める:
   \begin{displaymath}
    f(n, k) := \sum_{S \subseteq [n], |S| = k} \prod_{x \in S} x
   \end{displaymath}
   このとき、$p \not \mid f(n, k)$ となるような$0 \le k \le n$ の個数を、$\bmod\ 10^9+7$ で求めよ。(テストケースは$T$ケース与えられる。)

   制約: $1 \le T \le 4, 2 \le p \le 100000$, $p$は素数
   \begin{itemize}
    \item 部分点(10/100点): $n \le 5000$
    \item 部分点(50/100点): $n \le 100000$
    \item 満点(100点): $n < 10^{501}$
   \end{itemize}

   (出典: CodeChef February Challenge 2018 (FEB18) >> Lucas Theorem (LUCASTH))
  \end{itembox}
  簡単な式変形、DP、あるいは実験などで、
  \begin{displaymath}
   f(n, k) = ((t + 1) \times (2t + 1) \times \cdots \times (nt + 1) \mbox{の$t^k$の係数})
  \end{displaymath}
  であることがわかります。
  $P(n) := (t + 1) \times (2t + 1) \times \cdots \times (nt + 1)$と置きましょう。
  $P(n)$ の係数を愚直に計算することで、$O(n^2)$解法が得られます (10/100点)。

  これを高速化することを考えましょう。多項式の乗算を高速化したいので、FFTを使うことが思いつきます。分割統治で計算すれば、$O(n (\log n)^2)$解法が得られます (50/100点)。

  満点解法について考えましょう。先ほど紹介したフェルマーの小定理を少し修正することで、以下が分かります:
  \begin{displaymath}
   P(p - 1) = (t + 1) \times (2t + 1) \times \cdots \times ((p - 1)t + 1)
   \equiv -t^{p-1} + 1 \pmod p
  \end{displaymath}
  $(kt + 1) \bmod p$ は周期$p$なので、$P(pk) \equiv P(p)^k = (-t^{p-1}+1)^k \pmod p$
  が分かります。

  よって、$n = qp + r$ ($0 \le r < p$) としたとき、$P(n) \equiv P(qp)P(r) \equiv (-t^{p-1}+1)^qP(r) \pmod p$が計算できればよいです。

  $(-t^{p-1}+1)^q$ について考えましょう。今は$p$の倍数かどうかにだけ関心があるので、$(t^{p-1}+1)^q$ を考えても同じです。ここで、次のような事実が実験によって分かります:
  \begin{center}
   非負整数$a$ の $p$進表記を$a = (d_{e-1}d_{e-2}\cdots d_1d_0)_p$とすると、$(x+1)^a \bmod p$の0でない係数は、ちょうど$(d_{e-1} + 1) \times (d_{e-2} + 1) \times \cdots \times (d_0 + 1)$個ある。
  \end{center}
  これに$x = t^{p-1}$を代入すると、$q = (d_{e-1}d_{e-2}\cdots d_1d_0)_p$として、
  $(-t^{p-1}+1)^q \bmod p$ の0でない係数は$(d_{e-1} + 1) \times (d_{e-2} + 1) \times \cdots \times (d_0 + 1)$個あって、しかもそれぞれの次数は$p-1$次以上離れていることが分かります。$p$進表記を計算する方法は色々ありますが、$n$の桁数が小さいので、$O((\log n)^2)$時間かけて愚直に多倍長整数演算をすれば良いでしょう。

  次に$P(r)$ですが、$P(r)$は$r$次なので、$r < p - 1$ならば$(-t^{p-1}+1)^q$と干渉しないことが分かります。よって答えは$(d_{e-1} + 1) \times (d_{e-2} + 1) \times \cdots \times (d_0 + 1) \times (P(r)\bmod p\mbox{の0でない係数})$であることが分かります。
  $r = p - 1$の時は、$P(r) \equiv P(p) \pmod p$ より、$n = (q + 1)p$の時と同じ答えになることが分かります。

  以上から$O(p(\log p)^2 + (\log n)^2)$時間の解法が得られました。以下にソースコードを載せます。\url{https://www.codechef.com/viewsolution/17683322} です。
  実装には double 型の演算を用いた FFT を用いました。FFT の部分はソースコード\ref{fft.cpp} と同じです。25行目において、1の$n$乗根$\zeta = \cos(2\pi/n) + \sqrt{-1}\sin(2\pi/n)$の$i$乗 $\zeta^i = \cos(2\pi i/n) + \sqrt{-1}\sin(2\pi i/n)$を愚直に計算していることに注意しましょう。(気を利かせて、毎回$\zeta$を掛けることで$\zeta^i$を計算する、などすると誤差死します。ていうかしました)
  \lstinputlisting[caption=FEB18-LUCASTH.cpp,label=FEB18-LUCASTH.cpp]{FEB18-LUCASTH.cpp}

  また、 \url{http://math314.hateblo.jp/entry/2015/05/07/014908} を参考にした NTT による実装も行いました。
  ソースコードは割愛しますが、\url{https://www.codechef.com/viewsolution/17544576} で公開されています。double型FFTは2.16secで、NTTは2.72secで終了したので、両者に大きなパフォーマンスの違いはありません。(NTTは3並列でやったので、2並列にしたらNTTの方が早くなる可能性もあります。)
  \subsection{巡回群構造を用いた特殊な畳み込み~\level{4}}
  \label{subsec:convolution-with-primitive-roots}
  \begin{itembox}[l]{問題}
   素数$p$ と、長さ$n$の整数列$A$と、長さ $m$ の整数列 $B$ が与えられる。このとき、
   $(A_i B_j) \bmod p < l$ となるような組$\tuple{i, j}$ の個数を求めよ。

   制約: $2 \le p \le 250000$, $1 \le l \le p$, $2 \le n, m \le 10000000=10^7$,
   $A$ と $B$ は、種が与えられた乱数生成器によって生成される。

   (出典: Facebook Hacker Cup 2011 Round2 - Scott's New Trick \url{http://techtipshoge.blogspot.jp/2012/04/facebook-hacker-cup-2011-round2-scott.html})
  \end{itembox}
  $p$ の大きさが比較的小さめなので、$A_i \bmod p$ と $B_j \bmod p$ の出現回数を記録しておいて、あとでまとめて加算するという手法が思いつきます。つまり、以下のような操作を行うということです:
\begin{verbatim}
ac=[],bc=[];
for i in 0..n{
  ac[a[i]%p]++;
}
for i in 0..m{
  bc[b[i]%p]++;
}
ans=[];
for i in 0..p{
  for j in 0..p{
    ans[(i*j)%p]+=ac[i]*bc[j];
  }
}
\end{verbatim}
  この手法だと計算量は $O(p^2)$ です。

  これではうまく行かないので、高速化をしたいところです。
  ここで、上の擬似コードに畳み込みのようなものが出現していることに着目します。畳み込みで加算になっているべきところが\verb+(i*j)%p+ になっています。
  そのため、$(\Z/p\Z)^*$ の群構造に着目して、この問題を解きたいと思います。

  セクション~\ref{sec:group-theory} でみたように、$(\Z/p\Z)^*$は巡回群であることが知られています。つまり、ある要素 (生成元) $g \in (\Z/p\Z)^*$ が存在して、$(\Z/p\Z)^*$ の要素 $x \in (\Z/p\Z)^*$ はすべて、$x = g^i$ の形で表せるということです。このような$g$ のことを、$\bmod\ p$ における原始根と呼ぶのでした。
  ここで、$x = g^i$, $y = g^j$ とすると、$xy \bmod p = g^ig^j \bmod p = g^{i+j}$です。つまり、acやbcの添字を写像 $i \mapsto g^i$ で写せば、普通の畳み込みに帰着できます。

  原始根の計算方法について説明します。ある要素 $a \in (\Z/p\Z)^*$ が原始根であるかどうかは、brute force により $O(p)$ 時間で検査できます。それでは、原始根はどのくらいの割合で存在するでしょうか?
  ある原始根$g$に対して$a = g^i$ となっている場合、$\gcd(i, p - 1) = 1$ であることと
  $a$ が原始根であることは同値です。
  $p-1 = q_1^{e_1} \cdots q_k^{e_k}$を$p-1$の素因数分解とすると、上の条件を満たす$i$を選ぶ確率は$(q_1-1)\cdots(q_k-1)/q_1\cdots q_k$ です。$p\le 250000$ より、$k$ は最大でも$5$ 程度であり、$a$ が原始根である確率は十分大きいと言えるでしょう。以上より、ランダムに$a$を選び、原始根かどうか調べることによって、原始根を得ることができます。(もっと高速な方法もあります。考えてみましょう。答えはソースコード\ref{generator.py}の実装を読むと分かります。)

  実装するときは、$0$ 番目の要素の扱いに注意しましょう。$0$は$g^i$ の形で表せません。(この問題は公式のページが消えていて、実装してもジャッジできませんが…。)
  \subsection{1の$2^k$乗根$\bmod\ p$ を用いた畳み込み}
  \label{subsec:mod-convolution}
  素数$p$が特殊な形$p = u2^e + 1$ ($u$が小さく、$e$が大きい) の場合、$k \le e$ なる$k$に対して、$2^k$要素のFFTが (つまり結果として畳み込みが) できます。
  このような素数には、以下のようなものがあります。

  \begin{table}[htb]
   \begin{center}
    \begin{tabular}[tb]{|c|c|c|c|}
     \hline
     $p$ & $u \times 2^e + 1$ & 16進表記 & 最小の原始根 \\
     \hline
     998244353 & $119 \times 2^{23} + 1$ & \verb+0x3b800001+ & 3 \\
     163577857 & $39 \times 2^{22} + 1$ & \verb+0x9c00001+ & 23 \\
     167772161 & $5 \times 2^{25} + 1$ & \verb+0xa000001+ & 3 \\
     469762049 & $7 \times 2^{26} + 1$ & \verb+0x1c000001+ & 3 \\
     \hline
    \end{tabular}
   \end{center}
  \end{table}

  $\bmod\ p$ の原始根を$g$とすると、$g^u \bmod p$が$2^e$乗根を与えます。
  modの値が$10^9+7$以外の場合は、このような特殊な素数ではないかと疑ってみて、16進表示を求めるなどすると良いでしょう。

  有名な素数についてはもう原始根が計算されているので、それも表に書きました。
  表にない素数が出題された時のために、一応原始根を計算するスクリプトを載せておきます。Python 3で書かれています。
  \lstinputlisting[language=Python,caption=generator.py,label=generator.py]{generator.py}

  $\bmod\ p$ における1の$2^k$乗根を利用したFFT (NTT) については、\url{http://math314.hateblo.jp/entry/2015/05/07/014908} を参考にしてください。
 \section{ペル方程式\level{4}}
 \label{sec:pells-equation}
 \begin{itembox}[l]{問題}
  一辺$a$メートルの正方形がある。この正方形から、一辺$b$メートルの正方形を$n$個切り出すことを考える。ただし、切り出されなかった部分の面積は、元の正方形の面積の50\%以上でなければならない。つまり、$a^2-nb^2 \ge a^2/2$が必要である。

  ここで切り出されなかった部分のうち、$a^2$平方メートルの50\%を越える部分の面積
  (つまり$(a^2/2-nb^2)$平方メートル)を最小化したい。
  $n$が与えられるので、最小値を与える最小の正の整数$a,b$を与えよ。

  制約: $1 \le n \le 10000$

  (出典: Aizu Online Judge 2116: Subdividing a Land (ACM-ICPC Japan Alumni Group Practice Contest, for World Finals, Tokyo, Japan, 2008-02-23),
  \url{http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2116})
 \end{itembox}
 まず、 $2n$が平方数の場合、$a = \sqrt{2n},b=1$が最小値0を与えることが自明です。
 そうでない場合を考えます。$a^2 -2nb^2 \ge 0$ より $b \le a / \sqrt{2n}$ です。よって、1辺 $b$ の正方形を、縦横それぞれ $\floor{\sqrt{2n}}$ 個並べることができます。簡単な計算により、任意の正の整数 $n$ に対して $n \le \floor{\sqrt{2n}}^2$ であることがわかるので、1辺 $a$ の正方形の中に1辺 $b$ の正方形を確実に$n$個詰められることがわかります。つまり、結局 $a^2 - 2nb^2 \ge 0$の条件のもとで、$a^2 - 2nb^2$の最小値を与える最小の$a,b$を計算すれば良いことが分かります。

 ここで、以下の事実が知られています。
 \begin{theorem}
  \label{thm:pells-equation-has-solutions}
  $d$ が平方数でない正の整数のとき、方程式$x^2 - dy^2=1$は、正の整数解$\tuple{x, y}$を必ず持つ。
 \end{theorem}
 このような方程式を\emph{ペル方程式}\index{ぺるほうていしき@ペル方程式} (\emph{Pell's equation}) と呼び、
 このような$(x,y)$のうち、$x$が最小のものを\emph{基本解}\index{きほんかい@基本解} (\emph{fundamental solution}) と呼びます。この問題では、基本解が計算できれば良いです。

 ペル方程式の基本解を計算するアルゴリズムを説明します。連分数を使う、以下のアルゴリズムが広く知られています。

 \begin{algorithm}                      
  \caption{ペル方程式}
  \label{alg:pells-equation}
  入力: $d$: 正の整数、平方数でない

  出力: $\tuple{x, y}$, ただし$x, y$ は正の整数で $x^2 - dy^2 = 1$を満たす、$x,y$ はその中で最小

  1. $\alpha_0 := \sqrt{d}$ とする。

  2. $q_i := \floor{\alpha_i}, \alpha_{i+1} := 1/(\alpha_i - q_i)$ として無限数列を作る。この無限数列は、必ず循環する。

  3. 上で作った数列は、循環節が$q_1$から開始する。つまり、$(q_i) \colon q_0, q_1,\ldots, q_{m-1}, q_m, q_{1}, \ldots$ となる。このような最小の$m$をとり、
  \begin{displaymath}
   b := [q_0; q_1, \ldots, q_{m-1}] = q_0 + \frac{1}{q_1 + \frac{1}{\cdots + \frac{1}{q_{m-1}}}}
  \end{displaymath}
  とする。

  4. $b = x/y$ ($x$と$y$は互いに素な正の整数) としたとき、
  $x, y$ は $x^2 -dy^2 = \pm 1$ を満たす。
  $x^2 - dy^2 = 1$ の場合、$\tuple{x, y}$を出力する。
  $x^2 - dy^2 = -1$ の場合、$\tuple{x^2 + dy^2, 2xy}$を出力する。
 \end{algorithm}
 具体例として、$d = 14$ の場合にこのアルゴリズムがどう動くかを見てみましょう。
 数列 $\alpha_i$ と $q_i$ は以下のようになります:
 \begin{displaymath}
  \{a_i\}: \sqrt{14},
  \frac{3+\sqrt{14}}{5}, \frac{2+\sqrt{14}}{2},
  \frac{2+\sqrt{14}}{5}, 3+\sqrt{14},
  \frac{3+\sqrt{14}}{5}, \frac{2+\sqrt{14}}{2}, \ldots
 \end{displaymath}
 \begin{displaymath}
  \{q_i\}: 3, 1, 2, 1, 6, 1, 2, \ldots
 \end{displaymath}
 循環節は$q_1$ から$q_4$ までの長さ4の部分列です。$m = 4$ で、
 \begin{displaymath}
  b = [3; 1, 2, 1] = 15/4
 \end{displaymath}
 が成立します。$15^2 - 14 \times 4^2 = 1$であるため、出力は$\tuple{15, 4}$ となります。

 実装するときの注意として、$\alpha_i$の表現方法があります。実は、$\alpha_i$ は $\alpha_i = (x +\sqrt{d}) / z$ ($x, z$ は整数) という形で表せることが知られているので、この$x, z$ を保持すれば良いです。

 ソースコードを載せます。このソースコードは \url{http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2723600} で公開されています。
 \lstinputlisting[caption=aoj-2116.cpp,label=aoj-2116.cpp]{aoj-2116.cpp}
 \begin{itembox}[l]{COLUMN}
  定理\ref{thm:pells-equation-has-solutions} は、ディリクレの単数定理 (Dirichlet's unit theorem)~\cite[Theorem~5.13]{Stevenhagen2008} の特殊な場合で、$K = \Q(\sqrt{d})$ (実2次体) のオーダー $\Z[\sqrt{d}]$ の単数たちのなす乗法群 $U$ のランクが1である (つまり、$U \cong (\mbox{有限群}) \times \Z$ と表すことができる) ことを言っています。
  $\Z$ 成分の生成元のことを\emph{基本単数}\index{きほんたんすう@基本単数} (\emph{fundamental unit}) と呼びますが、上のアルゴリズムで求めた$\tuple{x, y}$ が基本単数$x + y\sqrt{d}$ を与えます。
  興味のある人は調べてみましょう。
 \end{itembox}
 \section{単項イデアル整域\level{5}}
 \label{sec:principal-ideal-domain}
 \begin{definition}
  可換環$R$が\emph{整域}\index{せいいき@整域} (\emph{integral domain}) であるとは、
  $x, y\in R$ が $xy = 0$ を満たすならば、$x$か$y$の少なくとも一方は$0$であることである。
 \end{definition}
 \begin{definition}
  可換環$R$の\emph{イデアル}\index{イデアル@イデアル} (\emph{ideal}) とは、$R$の部分集合$I$であって、以下の2条件を満たすものである:
  \begin{itemize}
   \item $x \in I, y \in I \to x + y \in I$
   \item $x \in R, y \in I \to xy \in I$
  \end{itemize}
 \end{definition}
 \begin{definition}
  可換環$R$とその要素$x \in R$に対して、$x$\emph{によって生成される単項イデアル} (\emph{a principal ideal generated by $x$}) とは、$xR := \{ xy \mid y \in R\}$ のことである。これを$(x)$と表記する。
 \end{definition}
 \begin{definition}
  可換環$R$とその要素$x_1,\ldots,x_n \in R$に対して、$x_1,\ldots,x_n$\emph{によって生成されるイデアル} (\emph{an ideal generated by $x_1,\ldots,x_n$}) とは、$\{ \sum_{i=1}^{n} \alpha_i x_i \mid \alpha_i \in R\}$ のことである。これを$(x_1,\ldots,x_n)$と表記する。
 \end{definition}
 \begin{definition}
  \emph{単項イデアル整域}\index{たんこういであるせいいき@単項イデアル整域} (\emph{principal ideal domain}, PID) (独: \emph{Hauptidealbereich}, ハウプトイデアールべライヒ) とは、全てのイデアルが単項生成であるような整域である。
 \end{definition}
 \begin{example}
  PIDの例として有名なのは、$\Z$, $\Z[i]$ ($i$は虚数単位)、 $K[x]$ (係数が$K$の元であるような多項式全体のなす集合、$K$は体)などです。逆にPIDでない例として有名なものには、$\Z[\sqrt{-5}]$ などがあります。
 \end{example}

 以下の問題を考えてみましょう。
 \begin{itembox}[l]{問題}
  $(P, Q)$-サンタがいる。$(P, Q)$-サンタは最初原点 $(0, 0)$ におり、$(x, y)$からは$(x \pm P, y \pm Q)$ または $(x \pm Q, y\pm P)$ の8種類の点に移動できる。
  $N$人の子供の座標$(X_i,Y_i)$が与えられるので、$(P, Q)$-サンタが到達できる子供の数を求めよ。

  (出典: yukicoder No.321 (P,Q)-サンタと街の子供たち)
 \end{itembox}
 この問題に限り、添字との混同を防ぐため、虚数単位を$\sqrt{-1}$と表記します。
 座標$(x,y)$に到達可能なとき、$x+y\sqrt{-1}$がどのような条件を満たすべきかを考えてみましょう。
 問題の移動は、$x+y\sqrt{-1}$から$x+y\sqrt{-1}\pm (P+Q\sqrt{-1})$,$x+y\sqrt{-1}\pm (P-Q\sqrt{-1})$,$x+y\sqrt{-1}\pm (Q+P\sqrt{-1})$,$x+y\sqrt{-1}\pm (Q-P\sqrt{-1})$の8種類の点に移動するものと考えることができます。
 $Q-P\sqrt{-1}=-\sqrt{-1}(P+Q\sqrt{-1})$, $Q+P\sqrt{-1}=\sqrt{-1}(P-Q\sqrt{-1})$に注意すると、結局移動できるのは
 \begin{displaymath}
  \alpha(P+Q\sqrt{-1}) + \beta(P-Q\sqrt{-1})
 \end{displaymath}
 (ただし、$\alpha,\beta \in \Z[\sqrt{-1}]$) で表される点ということが分かります。集合
 \begin{displaymath}
  \{\alpha(P+Q\sqrt{-1}) + \beta(P-Q\sqrt{-1}) \mid \alpha,\beta \in \Z[\sqrt{-1}]\}
 \end{displaymath}
 は、他でもないイデアル$(P+Q\sqrt{-1},P-Q\sqrt{-1})$であり、$\Z[\sqrt{-1}]$がPIDであるという性質から、$P+Q\sqrt{-1}$と$P-Q\sqrt{-1}$の最大公約数を$\gamma$と置くと、このイデアルは$\gamma$によって生成される単項イデアル$(\gamma)$です。よって、$\gamma | X_i+Y_i\sqrt{-1}$かどうかの判定を行うことで、この問題が解けました。なお、実装時には$\gamma = 0$ となるコーナーケース ($P = Q = 0$) に気をつけましょう。

 ソースコードを以下に載せます。\url{https://yukicoder.me/submissions/243652} です。
 \lstinputlisting[caption=yukicoder-321.cpp,label=yukicoder-321.cpp]{yukicoder-321.cpp}

 また、以下の問題を考えてみましょう。
 \begin{itembox}[l]{問題}
  $N$個の非負整数$A_i$が黒板に書かれている。
  以下の操作を何度でも行える:
  \begin{itemize}
   \item 黒板にある数を一つ選び、それを$x$とする。$2x$を新しく書き込む。
   \item 黒板にある数を二つ選び、それらを$x,y$とする(同じ数でも良い)。$x \mathbin{\mathrm{xor}} y$ を新しく書き込む。
  \end{itemize}
  最終的に書き込める数のうち、$X$以下のものは何種類あるか? 998244353で割った余りを求めよ。

  制約: $1 \le N \le 6$, $1 \le X < 2^{4000}$, $1 \le A_i < 2^{4000}$, $X$と$A_i$ は2進数で与えられ、先頭の桁は1。

  (出典: ARC084 F - XorShift)
 \end{itembox}
 まず、演算が2倍とxorなので、整数を以下のようにして、$\finiteField{2}[x]$ の元
 (つまり、$\finiteField{2}$ 係数の多項式) として表すという発想が自然です:
 \begin{displaymath}
  t = b_u 2^u + b_{u-1}2^{u-1} + \cdots + b_1 2 + b_0 \mapsto
  b_u x^u + b_{u-1} x^{u-1} + \cdots b_1 x + b_0
 \end{displaymath}
 多項式の上の演算として考えると、2倍する操作は$x$を掛ける操作、xorをとる操作は多項式の足し算です。 ($\finiteField{2}$ の上の足し算がxorであることに注意してください。)
 $\finiteField{2}[x]$ はPIDなので、この問題は、$\finiteField{2}[x]$の上の最大公約数が計算できれば解けます。
 つまり、整数$t$が黒板に書き込めることと、以下が同値です:
 \begin{displaymath}
  t \in (A_1, \ldots, A_N) = (\gcd(A_1, \ldots, A_N))
 \end{displaymath}
 この場合、最大公約数の計算一回には$O(|A_i|^2)$時間かかるので、全体の計算量は$O(N|A_i|^2)$となり、十分間に合います。ビット並列のテクニックを使うことで、$O(N|A_i|^2/64)$にしても良いでしょう。

 ソースコードは以下のようになります。\url{https://arc084.contest.atcoder.jp/submissions/2137652} です。
 \lstinputlisting[caption=ARC084F.cpp,label=ARC084F.cpp]{ARC084F.cpp}
\printindex
 \section*{謝辞}
 \label{sec:acknowledgements}
 全ての助けの中で、けんちょん (@drken1215) によるものが最大です。彼の協力により、問題がたくさん集まりました。また、定理\ref{thm:abundance-of-witnesses-in-karp1991} の証明には、かならい (@sugarknri) による助言が非常に大きな助けとなりました。その他、以下の方々にも助けをいただきました:
 \begin{itemize}
  \item minus3theta (@minus3theta)
  \item noicwt (@noicwt)
  \item $p$進大好きbot (@non\_archimedean)
 \end{itemize}
 感謝します。

 最後に、これを読んでくださった読者の方に感謝を述べて、筆を置かせていただきます。

\bibliographystyle{jplain}
\bibliography{./references}
\end{document}
