\documentclass{jsarticle}
\author{夕叢霧香 (Kirika Yuumura, @kirika\_comp)}
\title{整数論テクニック集 DRAFT}

\input{./macros.tex}
\makeindex
\begin{document}
\maketitle
 \section*{謝辞}
 \label{sec:acknowledgements}
 全ての助けの中で、dr.ken (@drken1215) によるものが最大です。彼の協力により、問題がたくさん集まりました。その他、以下の方々にも助けをいただきました:
 \begin{itemize}
  \item minus3theta (@minus3theta)
  \item noicwt (@noicwt)
  \item $p$進大好きbot (@non\_archimedean)
  \item かならい (@sugarknri)
 \end{itemize}
 感謝します。
 これを読んでくださる読者の方にも感謝の念を禁じえません。
 \section{はじめに}
 これは、競技プログラミングで使える整数論のテクニックをまとめた文章です。
 AtCoder の青から赤下位程度をターゲットにしています。

 整数論の問題は得てして「地頭ゲー」などと呼ばれやすいですが、実はそうではなく、知識を持っていることで解ける問題が多いです。しかし、その知識については、日本の競技プログラマーたちには、
 あまり知られていないように見えます。そのため、この文章を書くことにしました。

 基本的に、実際に出題されている問題で利用されるテクニックを、実際の問題と共に紹介するという方式で書いていきます。そのため、ネタバレは非常に多いです。ご注意ください。

 各セクションにはレベルを振ってあります。筆者が感じたおよその難易度を表しています。

 コメント等はTwitter (@kirika\_comp) までお願いします。
 \section{基本: アルゴリズムについて}
  \subsection{アルゴリズムにおける不変量}
  \label{subsec:invariant}
  アルゴリズムを考える時は、ループや再帰呼び出しのある地点で、どのような条件が常に成り立っているか、どのような値が保たれているかを考察することが、アルゴリズムの理解を助けることがあります。
  このような条件や値のことを、\emph{不変量}\index{ふへんりょう@不変量} (\emph{invariant}) と呼びます。

  例として、拡張ユークリッドの互除法の実装を与えます。
  ここで、各再帰呼び出しの\verb+return+ 直前に$ax+by=\gcd(a,b)$ が成り立っていることに注意してください。
  \lstinputlisting[caption=extgcd.cpp,label=extgcd]{./extgcd.cpp}
 \section{mod $p$上の計算}
 \label{sec:mod-p-arithmetic}
  \subsection{基本: 整数の加減乗除\level{1}}
  計算結果が大きすぎるため、${} \bmod (10^9+7)$で出力せよ、という問題が結構あります。
  このような問題の場合は、最終結果を${} \bmod (10^9+7)$するのではなく、途中結果も${} \bmod (10^9+7)$することで、途中結果が大きくなりすぎるのを防ぐことができます。

  なお除算については、次のサブセクションで説明する逆元を掛けることで実装することができます。
  \subsection{基本: 逆元\level{1}}
  \label{subsec:inverse-element}
  $p$を素数とします。
  $1 \le r < p$ の時、$rs \equiv 1 \pmod p, 1 \le s < p$を満たす$s$がただ一つ存在します。これを$r$の${} \bmod p$における\emph{逆元}\index{ぎゃくげん@逆元} (\emph{inverse element})と呼びます。
  逆元の計算には、以下の2種類の方法があります:
  \begin{enumerate}
   \item $r^{p-1} \equiv 1 \pmod p$ (フェルマーの小定理、定理\ref{thm:fermats-little-theorem})を利用して、$r^{p-2} \bmod p$を計算する。
   \item 拡張ユークリッドの互除法を使う。
  \end{enumerate}
  実装が単純なのは1.ですが、多くの場合で2.の方が高速に動作します。ライブラリを作る場合は、2.の方で作ると良いでしょう。

  以下に両方の実装を与えます。 実装TODO

  \subsection{基本: 分数の加減乗除\level{2}}
  \label{subsec:operations-on-fractions}
  たまに、分数についての言及があることがあります。大抵以下のような形をしています。
  \begin{center}
   答えは分数$A/B$ になる。このとき、$B$ の mod $(10^9+7)$ での逆元を$B^{-1}$ として、$A \times B^{-1} \bmod (10^9 + 7)$を出力せよ。
  \end{center}
  これも、特別な配慮などはせずに、途中結果をmod $(10^9+7)$ で保持しておくだけで、計算が正しく行えます。
  \begin{itembox}[l]{問題}
   \begin{itemize}
    \item Codeforces Round \#465 (Div. 2) D. Fafa and Ancient Alphabet
   \end{itemize}
  \end{itembox}
  \begin{itembox}[l]{COLUMN}
   専門用語を使うと、これは素数 $p$ について自然に定まる環準同型$\Z \to \Z/p\Z$が、環準同型$\Z_{(p)} \to \Z/p\Z$ に拡張できる、ということができます(ただし、$\Z_{(p)}$は、$\Z$のイデアル$(p)$による\emph{局所化}と呼ばれるもので、分子が任意、分母が$p$の倍数でないような分数全体からなる環)。興味のある人は、「局所化」や「附値環」などの単語で調べてみてください。
  \end{itembox}
 \section{二分累乗法\level{1}}
 \label{sec:exponentiation-by-squaring}
 二分累乗法とよばれる基本テクニックがあります。

 ある種の「掛け算」$x \cdot y$ が定義されているような代数的構造 (\emph{モノイド}と呼びます) の上で、$x$ の $e$乗 $x^e = x \cdot \cdots \cdot x$は$2\log_2 e$回以内の掛け算で計算できます。この方法を\emph{二分累乗法}\index{にぶんるいじょうほう@二分累乗法} (\emph{exponentiation by squaring}) と呼びます。

 二分累乗法には2種類の方法があります。一つ目は、$e$の2進表記の小さい桁の方から計算をする方法で、もう一つは$e$ の2進表記の大きい桁の方から計算をする方法です。整数のmodつき掛け算を例にして、両方のアルゴリズムを紹介します。

 まず一つ目から紹介します。ソースコード\ref{powmod-1.cpp}に実装を載せました。
 ループの各イテレーション終了時に$prod * cur^e = (answer) = x^e$ が成立していることに注意しましょう。最終的に$e = 0$ となって $prod$ に答えが入ります。
 \lstinputlisting[caption=powmod-1.cpp,label=powmod-1.cpp]{powmod-1.cpp}

 次に二つ目を紹介します。$e$ の上の桁から見ていくアルゴリズムです。
 ループの各イテレーション終了時に$prod^{2^i} * x^{e \% 2^i} = (answer) = x^e$ が成り立つことに注意しましょう。
 \lstinputlisting[caption=powmod-2.cpp,label=powmod-2.cpp]{powmod-2.cpp}
  \subsection{群的構造を見つけて二分累乗する\level{2}}
  \begin{itembox}[l]{問題}
   $\cos \theta = \frac{d}{l}$であるような$\theta$に対して、$\cos t\theta$は有理数であることが証明できる。$l\cos t\theta = \frac{p}{q}$であるとき、$pq^{-1} \bmod (10^9+7)$を求めよ。
   \begin{itemize}
    \item 部分点(15/100点): $t$は2冪である。つまり、ある0以上の整数$p$について$t=2^p$。
    \item 満点(100点): $1 \le t \le 10^{18}$, $t$は整数。
   \end{itemize}
   (出典: CodeChef February Challenge 2018 (FEB18) >> Broken Clock (BROCLK))
  \end{itembox}
  部分点解法は、2倍角の公式$\cos 2\theta = 2\cos^2\theta - 1$を利用して、$p$回の計算を行うことでできます。

  問題は満点解法の方で、愚直にやると$t$倍角の公式が必要になってきて、不可能とは言わないまでも面倒です。そこで、ド・モアブルの公式 (de Moivre's formula)
  \begin{displaymath}
   \cos t\theta + i\sin t\theta = (\cos\theta + i\sin\theta)^t
  \end{displaymath}
  を利用して、強引に冪乗公式に持っていくことを考えましょう。
  式の形から、$\cos \theta + i\sin\theta$なる数の計算、およびそれの累乗の計算ができれば良いことになります。ここで、以下のようにペアを用いて数を表現することにします:
  \begin{displaymath}
   \langle a, b\rangle \mapsto a + ib\sin \theta
  \end{displaymath}
  これにより掛け算、それゆえ冪乗が、整数ペアの上の演算として実装できます。どのようにするかみていきましょう。

  まず、$\cos\theta + i\sin\theta$はもちろん、$\langle \cos\theta,1\rangle=\langle d/l,1\rangle$として表現されます。掛け算についてですが、
  \begin{displaymath}
   \langle a,b\rangle \times \langle c,d\rangle = (a+ib\sin\theta)(c+id\sin\theta)
   =(ac-bd\sin^2\theta)+i(ad+bc)\sin\theta
   =\langle ac+bd(\cos^2\theta-1), ad+bc\rangle
  \end{displaymath}
  より、問題なく実装することができます。これによりべき乗も問題なく実装でき、問題が解けます。
  \lstinputlisting[caption=BROCLK.cpp,label=BROCLK]{FEB18-BROCLK.cpp}
  \subsection{うまい変形で除算を回避する\level{2}}
  \label{subsec:avoiding-division}
  \begin{itembox}[l]{問題}
   整数$A$が、次のような10進表記で与えられる。
   \begin{displaymath}
    (A)_{10} = a_1^{L_1} \cdot a_2^{L_2} \cdot \dots \cdot a_N^{L_N}
   \end{displaymath}
   ここで、$a_i$は10進表記で与えられた整数、$L_i$は整数である。
   また$a_i^{L_i}$は、$a_i$を文字列としてみなして、$L_i$個連結したものを表し、$s \cdot t$ は文字列 $s$, $t$ の連結を表す。
   このとき、$A$を$B$で割った余りを求めよ。

   制約: $1 \le N \le 10000, 1\le a_i \le 10^9, 1 \le L_i \le 10^9$
   \begin{itemize}
    \item 部分点 (99/100点): $B = 10^9+7$。
    \item 満点 (100点): $1 \le B \le 10^9 + 7$。$B$ は素数とは限らない。
   \end{itemize}

   (出典: ARC020 C - A mod B Problem)
  \end{itembox}
  $B$が素数の場合、$A$は等比数列の総和の公式を使って、以下のような閉じた式の形で書けるので、計算することは簡単です。ここで、$b_i$は$a_i$の桁数です。
  \begin{displaymath}
   A = a_N f(10^{b_N},l_N)+10^{b_N \times l_N}(a_{N-1}f(10^{b_{N-1}},l_{N-1}) + 10^{b_{N-1} \times l_{N-1}} ( \ldots)),
   f(y,z) = 1+y+\cdots+y^{z-1} = \frac{y^z-1}{y-1}
  \end{displaymath}
  問題は$B$が素数でない場合です。
  $f(y,z)$の計算の中で、$y-1$による除算を行っていますが、$y-1$と$B$が互いに素でない場合に、これは失敗します。
  これを回避するために、$y^z$を二分累乗法で計算するのを諦め、$f(y,z)$を直接二分累乗法に似た方法で計算することを考えましょう。以下の等式が成立します:
  \begin{displaymath}
   f(y,2z) = 1+y+\cdots+y^{2z-1}=(1+y+\cdots+y^{z-1})(1+y^z)=(1+y^z)f(y,z)
  \end{displaymath}
  \begin{displaymath}
   f(y,z+1)=1+y+\cdots+y^{z}=1+y(1+y+\cdots+y^{z-1})=1+yf(y,z)
  \end{displaymath}
  これによって、$z$の偶奇に応じて場合分けしながら再帰を行うことで、$f(y,z)$の値を除算なしで計算することができます。
  ソースコードTODO
 \section{${}\bmod p$ のアルゴリズム}
  \subsection{基礎知識}
  \label{subsec:group-preliminaries}
   \subsubsection{フェルマーの小定理\level{1}}
   \begin{theorem}
    \label{thm:fermats-little-theorem}
    $p$が素数で$a \not \equiv 0 \pmod p$ のとき、 $a^{p-1} \equiv 1 \pmod p$が成立する。
   \end{theorem}
   \subsubsection{平方剰余\level{3}}
   \label{subsubsec:quadratic-residue}
   $a \equiv x^2 \pmod p$ となる $x$ が存在する場合、$a$を${}\bmod p$ における \emph{平方剰余}\index{へいほうじょうよ@平方剰余} (\emph{quadratic residue})、そうでない場合 $a$ を\emph{平方非剰余}\index{へいほうひじょうよ@平方非剰余} (\emph{quadratic non-residue})と呼びます。
   $p$ が奇素数の時、0を除くと平方剰余と平方非剰余の割合は1:1です。
   また、$a\not\equiv 0 \pmod p$ のとき$a^{(p-1)/2}$ は ${}\bmod p$ で $1$ か $-1$ かのどちらかですが、$a$ が平方剰余のとき$1$、平方非剰余のとき$-1$です。
   \begin{example}
    $p = 13$ の場合を考えます。このとき、平方剰余は$0=0^2$,$1=1^2$,$3\equiv 4^2$,$4=2^2$,$9=3^2$,$10\equiv 6^2$,$12 \equiv 5^2 \pmod{13}$の7個です。0を除外すると1,3,4,9,10,12の6個で、${}\bmod 13$の0以外の同値類12個のうち、ちょうど半分が平方剰余、もう半分が平方非剰余です。なお、適当な平方非剰余$z$をとると、0以外の平方剰余に$z$を掛けたものはすべて平方非剰余です。例えば、$z=2$とすると、1,3,4,9,10,12に2を掛けて${}\bmod 13$したもの(2,6,8,5,7,11)はすべて平方非剰余です。
   \end{example}
   \subsubsection{加法群\level{4}}
   $\Z/p\Z$の話 TODO
   素数$p$ に対して、$p$で割った余り全体の集合を$\Z/p\Z$と書きます。$\Z/p\Z$ は、加法を演算として、群の構造を持ちます。
   \subsubsection{乗法群\level{4}}
   $\Z/p\Z$ のうち、0以外の元には乗法の逆元が存在することは、\ref{subsec:inverse-element}で確かめました。これらの元からなる集合を$(\Z/p\Z)^*$ と表記し、$\Z/p\Z$の\emph{乗法群} \index{じょうほうぐん@乗法群} (\emph{multiplicative group}) と呼びます。

   平方剰余全体は$(\Z/p\Z)^*$の部分群 TODO
   平方剰余全体の集合をここでは$H$と書くことにします。$H$は $(\Z/p\Z)^*$ の部分群です。
   \ref{subsubsec:quadratic-residue} でみたように、平方非剰余$z$を適当にとると、$zH$と$H$は共通部分を持たず、また$H \cup zH = (\Z/p\Z)^*$ です。
\subsection{mod\_sqrt, Tonelli-Shanks のアルゴリズム\level{3}}
\subsubsection{問題}
ある $x$ について $a \equiv x^2 \pmod p$ が成り立つ $a$ が与えられる。この時、$x$ を求めよ。

\subsubsection{解法}
まず、簡単のため $p = 2$ の場合を除外します(このときは$a^2 \equiv a \pmod 2$ なので簡単)。また$a \equiv 0 \pmod p$ の場合も除外します($0^2 = 0$なので簡単)。
$p$ が${}\bmod 4$ で3の時は簡単です。$x \equiv a^{(p+1)/4}$とすると、$x^2 \equiv a^{(p+1)/2}$ です。ここで、$a \equiv y^2$ となる $y$ が存在するので、$a^{(p-1)/2}\equiv y^{p-1}\equiv 1 \pmod p$ です。
だから、$x^2 \equiv a$ が成り立ちます。

$p$ が ${}\bmod 4$ で 1の時は結構複雑なことをします。ここではTonelli-Shanksの方法と呼ばれるアルゴリズムを説明します。

\subsubsection{Tonelli-Shanks (トネリ-シャンクス) のアルゴリズム}
Reference: \url{https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm}

注意: 以下の疑似コードでは代入は全部同時に行います。特に5.で、$t$に代入する値は前の $c$ によって決まります。

注意2: 本来の Tonelli-Shanks とは違いますが、不変量を考えることで筆者が復元できたのが以下のアルゴリズムなので、こちらの方が理解しやすいと思います。(効率は悪い)

\begin{algorithm}                      
\caption{単純化された Tonelli-Shanks のアルゴリズム}
\label{alg1}
入力: $p (\ge 3)$: 奇素数, $a (\not \equiv 0 \pmod p)$: 平方剰余

出力: $r^2 \equiv a \pmod p$ を満たす$r$

$p = q \times 2^s + 1$ とします。 ($s \ge 1$, $q$は奇数)

1. $z^{(p-1)/2} \equiv -1 \pmod p$ となるような $z$ を選ぶ。このような $z$ は確率1/2でヒットするため、何個か試せば必ず見つかる。

2. $m := s, c:\equiv z^q, t :\equiv a^q, r :\equiv a^{(q + 1)/2}$ とする。以降不変量 $\bm{r^2\equiv at \pmod p, t^{2^{m - 1}} \equiv 1 \pmod p, c^{2^{m-1}} \equiv -1 \pmod p}$ を崩さないように注意して操作する。

3. 以降 $m$ を減らしていく。$m$ が1なら終了。そうでなければ、$t^{2^{m-2}} \equiv 1 \pmod p$ なら4.へ、そうでなければ5.へ行く。

4. $c :\equiv c^2 \pmod p, m := m - 1$, 6.へ行く。

5. $c :\equiv c^2 \pmod p, t :\equiv c^2 t \pmod p, r :\equiv cr \pmod p, m := m - 1$ を\emph{全て同時に}代入する, 6.へ行く。

6. 3.へ行く。

\end{algorithm}
終了時には$m=1$なので、$t\equiv 1 \pmod p$になっているはずで、そのときの $r$ が求める値です。(不変量 $r^2\equiv at \pmod p$ に注意。)



C++での実装はソースコード\ref{alg:tonell-shanks}のようになります。
\lstinputlisting[caption=tonelli-shanks.cpp,label=alg:tonell-shanks]{tonelli-shanks.cpp}

例を挙げて見ていきましょう。
$p = 41$, $a = 8$ とします。

$p = 5 * 2^3 + 1$ なので、$q = 5, s = 3$ です。
$z$ として、ここでは 7 をとります。

$m := 3, c :\equiv 7^5 = 16807 \equiv 38, t :\equiv 8^5 = 32768 \equiv 9, r \equiv 8^3 = 512 \equiv 20$ となります。 (${} \bmod 41$ は適宜省略)

 \begin{table}[htb]
  \begin{center}
  \begin{tabular}[t]{|c|c|c|c|}
   \hline
   $m$ & $c$ & $t$ & $r$ \\ \hline
   3 & 38 & 9 & 20 \\
   2 & 9 & 40 & 22 \\
   1 & 40 & 1 & 34 \\ \hline
  \end{tabular}
  \end{center}
 \end{table}


よって、$x \equiv \pm 34 (=\mp 7)$ が答えになります。


以上のアルゴリズムで、4.のパートに無駄があります。4.では$c$と$m$しか変更していないので、$t^{2^i}\not \equiv 1 \pmod p$ となる最大の $i$ が見つけられれば、4.の操作をまとめることができます。このアイデアを使うのが、本来の Tonelli-Shanks のアルゴリズムです。

(TODO Wikipedia のTonelli-Shanks の説明)

\begin{itembox}[l]{COLUMN}
 群論的なアプローチをすると、もっと綺麗な見方が得られます。
$(\Z/p\Z)^* \cong \Z/(p-1)\Z \cong (\Z/2^s\Z) \times (\Z/q\Z)$ の2冪成分(2-Sylow部分群\index{Sylowぶぶんぐん@Sylow部分群}) $H = \Z/2^s\Z$ を考えます。このとき、$z$ と $t$ は $H$ の元であることがわかります。$t$が$1$になるように、うまく$H^2$の元で調整しているわけです。
\end{itembox}
 \section{多項式を使うテク\level{4}}
 \label{sec:technique-using-polynomials}
  \subsection{FFT}
  TODO説明
  \subsection{フェルマーの小定理}
  以下の等式が成り立ちます:
  \begin{displaymath}
   (x+1) \times (x+2) \times \cdots \times (x + (p - 1)) \equiv x^{p-1} - 1 \pmod p
  \end{displaymath}
  説明TODO

  この事実を応用して解ける問題を紹介します。以下の問題を考えましょう。
  \begin{itembox}[l]{問題}
   正の整数$n$と素数$p$が与えられる。$[n] := \{1,\ldots, n\}$ として、整数$k$に対して$f(n, k)$ を以下で定める:
   \begin{displaymath}
    f(n, k) := \sum_{S \subseteq [n], |S| = k} \prod_{x \in S} x
   \end{displaymath}
   このとき、$p \not \mid f(n, k)$ となるような$0 \le k \le n$ の個数を、${} \bmod 10^9+7$ で求めよ。(テストケースは$T$ケース与えられる。)

   制約: $1 \le T \le 4, 2 \le p \le 100000$, $p$は素数
   \begin{itemize}
    \item 部分点(10/100点): $n \le 5000$
    \item 部分点(50/100点): $n \le 100000$
    \item 満点(100点): $n < 10^{501}$
   \end{itemize}

   (出典: CodeChef February Challenge 2018 (FEB18) >> Lucas Theorem (LUCASTH))
  \end{itembox}
  簡単な式変形、DP、あるいは実験などで、
  \begin{displaymath}
   f(n, k) = ((t + 1) \times (2t + 1) \times \cdots \times (nt + 1) \mbox{の$t^k$の係数})
  \end{displaymath}
  であることがわかります。
  $P(n) := (t + 1) \times (2t + 1) \times \cdots \times (nt + 1)$と置きましょう。
  $P(n)$ の係数を愚直に計算することで、$O(n^2)$解法が得られます (10/100点)。

  これを高速化することを考えましょう。多項式の乗算を高速化したいので、FFTを使うことが思いつきます。分割統治で計算すれば、$O(n (\log n)^2)$解法が得られます (50/100点)。

  満点解法について考えましょう。先ほど紹介したフェルマーの小定理を少し修正することで、以下が分かります:
  \begin{displaymath}
   P(p - 1) = (t + 1) \times (2t + 1) \times \cdots \times ((p - 1)t + 1)
   \equiv -t^{p-1} + 1 \pmod p
  \end{displaymath}
  $(kt + 1) \bmod p$ は周期$p$なので、$P(pk) \equiv P(p)^k = (-t^{p-1}+1)^k \pmod p$
  が分かります。

  よって、$n = qp + r$ ($0 \le r < p$) としたとき、$P(n) \equiv P(qp)P(r) \equiv (-t^{p-1}+1)^qP(r) \pmod p$が計算できればよいです。

  $(-t^{p-1}+1)^q$ について考えましょう。今は$p$の倍数かどうかにだけ関心があるので、$(t^{p-1}+1)^q$ を考えても同じです。ここで、次のような事実が実験によって分かります:
  \begin{center}
   非負整数$a$ の $p$進表記を$a = (d_{e-1}d_{e-2}\cdots d_1d_0)_p$とすると、$(x+1)^a \bmod p$の0でない係数は、ちょうど$(d_{e-1} + 1) \times (d_{e-2} + 1) \times \cdots \times (d_0 + 1)$個ある。
  \end{center}
  これに$x = t^{p-1}$を代入すると、$q = (d_{e-1}d_{e-2}\cdots d_1d_0)_p$として、
  $(-t^{p-1}+1)^q \bmod p$ の0でない係数は$(d_{e-1} + 1) \times (d_{e-2} + 1) \times \cdots \times (d_0 + 1)$個あって、しかもそれぞれの次数は$p-1$次以上離れていることが分かります。$p$進表記を計算する方法は色々ありますが、$n$の桁数が小さいので、$O((\log n)^2)$時間かけて愚直に多倍長整数演算をすれば良いでしょう。

  次に$P(r)$ですが、$P(r)$は$r$次なので、$r < p - 1$ならば$(-t^{p-1}+1)^q$と干渉しないことが分かります。よって答えは$(d_{e-1} + 1) \times (d_{e-2} + 1) \times \cdots \times (d_0 + 1) \times (P(r)\bmod p\mbox{の0でない係数})$であることが分かります。
  $r = p - 1$の時は、$P(r) \equiv P(p) \pmod p$ より、$n = (q + 1)p$の時と同じ答えになることが分かります。

  以上から$O(p(\log p)^2 + (\log n)^2)$時間の解法が得られました。以下にソースコードを載せます。\url{https://www.codechef.com/viewsolution/17544576} です。
  \lstinputlisting[caption=FEB18-LUCASTH.cpp,label=FEB18-LUCASTH.cpp]{FEB18-LUCASTH.cpp}
 \section{平方剰余の相互法則\level{4}}
  \subsection{ルジャンドル記号}
  \label{subsec:legendre-symbol}
  ルジャンドル記号\index{るじゃんどるきごう@ルジャンドル記号}とは、以下で定義されるものです。
  \begin{displaymath}
   \legendre{a}{p} := \begin{cases}
		      1 & \mbox{$a$が平方剰余のとき} \\
		      -1 & \mbox{$a$が平方非剰余のとき}\\
		      0 & \mbox{$a \equiv 0 \pmod p$のとき}
		     \end{cases}
  \end{displaymath}

  \begin{proposition}
   \begin{displaymath}
     \legendre{a}{p} \equiv a^{\frac{p-1}{2}} \pmod p
    \end{displaymath}
  \end{proposition}
  \begin{proposition}
   ルジャンドル記号は乗法的である。つまり、
   \begin{displaymath}
    \legendre{a}{p} \legendre{b}{p} = \legendre{ab}{p}
   \end{displaymath}
  \end{proposition}
  \begin{corollary}
   対応 $a \mapsto \legendre{a}{p}$ は群準同型$(\Z/p\Z)^* \to \{+1,-1\}$ を定める。
  \end{corollary}
  \subsection{平方剰余の相互法則}
  以下の定理が成り立つことが知られています。
  \begin{theorem}[平方剰余の相互法則]
   $p, q \ge 3$ を奇素数とする。このとき、以下が成立する。
   \begin{displaymath}
    \left(\frac{p}{q}\right)\left(\frac{q}{p}\right) = (-1)^{\frac{p-1}{2} \times \frac{q-1}{2}}
   \end{displaymath}
  \end{theorem}
  \begin{theorem}[補充法則]
   $p \ge 3$ を奇素数とする。このとき、以下が成立する。
   \begin{displaymath}
    \legendre{-1}{p} = (-1)^{\frac{p-1}{2}},
    \legendre{2}{p} = (-1)^{\frac{p^2-1}{8}}
   \end{displaymath}
  \end{theorem}
  これを利用することで、ルジャンドル記号を計算できます。
  \begin{example}
   \label{ex:legendre-3}
   $p \neq 2,3$を、2,3以外の素数とします。このとき、
   $\legendre{3}{p}$ は、$p$ を12で割った余りで完全に決まります。
   \begin{displaymath}
    \legendre{3}{p} = (-1)^{\frac{p-1}{2}}\legendre{p}{3}
   \end{displaymath}
   ここで、
   \begin{displaymath}
    \legendre{p}{3} = \begin{cases}
		       1 & \mbox{if }p\equiv 1 \pmod 3 \\
		       -1 & \mbox{if }p\equiv 2 \pmod 3
		      \end{cases}
   \end{displaymath}
   なので、
   \begin{displaymath}
    (-1)^{\frac{p-1}{2}} = \begin{cases}
			    1 & \mbox{if }p \equiv 1 \pmod 4 \\
			    -1 & \mbox{if }p \equiv 3 \pmod 4
			   \end{cases}
   \end{displaymath}
   と合わせ、
   \begin{displaymath}
    \legendre{3}{p} = \begin{cases}
		       1 & \mbox{if }p\equiv 1,11 \pmod{12} \\
		       -1 & \mbox{if }p\equiv 5,7 \pmod{12}
		      \end{cases}
   \end{displaymath}
   が得られます。
  \end{example}
  \subsection{2次体}
  \label{subsec:quadratic-field}
  有理数体 $\Q$ に有理数の平方根$\sqrt{d}$を添加した体 $\Q(\sqrt{d})$ を、\emph{2次体}\index{にじたい@2次体} (\emph{quadratic field})と呼びます。
  \subsection{有限体}
  任意の素数$p$と正の整数$e$に対して、$p^e$要素の有限体が存在します。逆に、有限体の要素数は、必ず$p^e$ の形で表せます。このような有限体は、一意に存在します。これを$\finiteField{p^e}$と表記することにします。
  \subsection{フロベニウス写像}
  $\Frob \colon \finiteField{p^e} \to \finiteField{p^e}, \Frob(x) := x^p$ を\emph{フロベニウス写像}\index{ふろべにうすしゃぞう@フロベニウス写像}と呼びます。 TODO
  \begin{proposition}
   $\Frob$は$e$回適用すると元に戻る。つまり、$\Frob^e(x) = x$。
  \end{proposition}
  \begin{proposition}
   $x, \Frob(x), \Frob^2(x), \ldots, \Frob^{e-1}(x)$ は全て共役(TODO definition)。つまり、TODO。
  \end{proposition}
  \subsection{応用例}
  \begin{itembox}[l]{問題}
   数列 $a_0 = 2, a_{n+1} = a_n(a_n+4)$がある。このとき、素数$M$に対して、$a_N \bmod M$ を求めよ。

   (出典: yukicoder No.613 Solitude by the window)
  \end{itembox}
  この問題は、一般項を求めるところが一番難しく、一般項を求めた後は数論的な考察を進めるだけで解けます。
  ここでは、$a_n = (2+\sqrt{3})^{2^n} + (2-\sqrt{3})^{2^n} - 2$ であることがわかっているとして、この状態から問題を解いてみましょう。$a_n \bmod M$が計算できれば良いです。

  $(2+\sqrt{3})^{2^n} \bmod M$が計算できれば万事解決です。
  簡単のため、$M$が2でも3でもないとしましょう。先にも述べた(TODO)通り、3が${}\bmod M$で平方剰余なら(つまり$\legendre{3}{M}=1$なら)、議論は$\finiteField{M}$の中で完結できます。
  3が${}\bmod M$で平方非剰余(つまり$\legendre{3}{M}=-1$)の場合を考えます。
  このとき、$\finiteField{M}$に$\sqrt{3}$を添加して拡大したものは、$\finiteField{M^2}$と同型になります。
  \begin{displaymath}
   \finiteField{M}(\sqrt{3}) \cong \finiteField{M^2}
  \end{displaymath}
  ここで、$\Frob(2+\sqrt{3}) = (2+\sqrt{3})^M \in \finiteField{M^2}$がどのような元になるかを考えてみましょう。$2+\sqrt{3}$の共役は自分自身と$2-\sqrt{3}$のみなので、$\Frob(2+\sqrt{3})=2-\sqrt{3}$でなければなりません。これから、$(2+\sqrt{3})^{M+1}=(2-\sqrt{3})(2+\sqrt{3})=1$であることが分かります。
 \section{mod\_sqrt その2\level{3}}
 Karp (1991)~\cite{Karp1991}
 \section{mod\_sqrt その3\level{4}}
 http://pekempey.hatenablog.com/entry/2017/02/03/220150

 Cipolla のアルゴリズム
 \section{ペル方程式\level{4}}
 \label{sec:pells-equation}
 \begin{itembox}{問題}
  一辺$a$メートルの正方形がある。この正方形から、一辺$b$メートルの正方形を$n$個切り出すことを考える。ただし、切り出されなかった部分の面積は、元の正方形の面積の50\%以上でなければならない。つまり、$a^2-nb^2 \ge a^2/2$が必要である。

  ここで切り出されなかった部分のうち、$a^2$平方メートルの50\%を越える部分の面積
  (つまり$(a^2/2-nb^2)$平方メートル)を最小化したい。
  $n$が与えられるので、最小値を与える正の整数$a,b$を与えよ。

  制約: $1 \le n \le 10000$

  (出典: Aizu Online Judge 2116: Subdividing a Land (ACM-ICPC Japan Alumni Group Practice Contest, for World Finals, Tokyo, Japan, 2008-02-23),
  \url{http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2116})
 \end{itembox}
 まず、 $2n$が平方数の場合、$a = \sqrt{2n},b=1$が最小値0を与えることが自明です。
 そうでない場合を考えます。$n$が十分に大きい場合には、(気の遠くなるような計算 TODO) $a^2 - 2nb^2 \ge 0$ならば$n$個詰めることが確実にできることが保証されるので、結局 $a^2 - 2nb^2 \ge 0$の条件つきで、$a^2 - 2nb^2$の最小値を与える$a,b$を計算すれば良いことが分かります。

 ここで、以下の事実が知られています。
 \begin{theorem}
  \label{thm:pells-equation-has-solutions}
  $n$が平方数でない正の整数のとき、方程式$x^2 - ny^2=1$は、正の整数解$(x,y)$を必ず持つ。
 \end{theorem}
 このような方程式を\emph{ペル方程式}\index{ぺるほうていしき@ペル方程式} (\emph{Pell's equation}) と呼び、
 このような$(x,y)$のうち、$x$が最小のものを\emph{基本解}\index{きほんかい@基本解} (\emph{fundamental solution}) と呼びます。この問題では、基本解が計算できれば良いでしょう。

 ペル方程式の基本解を計算するアルゴリズムを説明します。連分数を使う、以下のアルゴリズムが広く知られています。TODO
 \section{単項イデアル整域\level{5}}
 \label{sec:principal-ideal-domain}
 \begin{definition}
  可換環$R$が\emph{整域}\index{せいいき@整域} (\emph{integral domain}) であるとは、
  $x, y\in R$ が $xy = 0$ を満たすならば、$x$か$y$の少なくとも一方は$0$であることである。
 \end{definition}
 \begin{definition}
  可換環$R$の\emph{イデアル}\index{イデアル@イデアル} (\emph{ideal}) とは、$R$の部分集合$I$であって、以下の2条件を満たすものである:
  \begin{itemize}
   \item $x \in R, y \in R \to x + y \in R$
   \item $x \in R, y \in I \to xy \in R$
  \end{itemize}
 \end{definition}
 \begin{definition}
  可換環$R$とその要素$x \in R$に対して、$x$\emph{によって生成される単項イデアル} (\emph{a principal ideal generated by $x$}) とは、$xR = \{ xy \mid y \in R\}$ のことである。これを$(x)$と表記する。
 \end{definition}
 \begin{definition}
  \emph{単項イデアル整域}\index{たんこういであるせいいき@単項イデアル整域} (\emph{principal ideal domain}, PID) (独: \emph{Hauptidealbereich}, ハウプトイデアールべライヒ) とは、全てのイデアルが単項生成であるような整域である。
 \end{definition}
 \begin{example}
  PIDの例として有名なのは、$\Z$, $\Z[i]$ ($i$は虚数単位)、 $K[x]$ (係数が$K$の元であるような多項式全体のなす集合、$K$は体)などです。逆にPIDでない例として有名なものには、$\Z[\sqrt{-5}]$ などがあります。
 \end{example}

 以下の問題を考えてみましょう。
 \begin{itembox}[l]{問題}
  $(P, Q)$-サンタがいる。$(P, Q)$-サンタは最初原点におり、$(x, y)$からは$(x \pm P, y \pm Q)$ または $(x \pm Q, y\pm P)$ の8種類の点に移動できる。
  $N$人の子供の座標$(X_i,Y_i)$が与えられるので、$(P, Q)$-サンタが到達できる子供の数を求めよ。

  (出典: yukicoder No.321 (P,Q)-サンタと街の子供たち)
 \end{itembox}
 この問題に限り、添字との混同を防ぐため、虚数単位を$\sqrt{-1}$と表記します。
 座標$(x,y)$に到達可能として、$x+y\sqrt{-1}$がどのような条件を満たすべきかを考えてみましょう。
 問題の移動は、$x+y\sqrt{-1}$から$x+y\sqrt{-1}\pm (P+Q\sqrt{-1})$,$x+y\sqrt{-1}\pm (P-Q\sqrt{-1})$,$x+y\sqrt{-1}\pm (Q+P\sqrt{-1})$,$x+y\sqrt{-1}\pm (Q-P\sqrt{-1})$の8種類の点に移動するものと考えることができます。
 $Q-P\sqrt{-1}=-\sqrt{-1}(P+Q\sqrt{-1})$, $Q+P\sqrt{-1}=\sqrt{-1}(P-Q\sqrt{-1})$に注意すると、結局移動できるのは
 \begin{displaymath}
  \alpha(P+Q\sqrt{-1}) + \beta(P-Q\sqrt{-1})
 \end{displaymath}
 (ただし、$\alpha,\beta \in \Z[\sqrt{-1}]$) で表される点ということが分かります。集合
 \begin{displaymath}
  \{\alpha(P+Q\sqrt{-1}) + \beta(P-Q\sqrt{-1}) \mid \alpha,\beta \in \Z[\sqrt{-1}]\}
 \end{displaymath}
 は、他でもないイデアル$(P+Q\sqrt{-1},P-Q\sqrt{-1})$であり、$\Z[\sqrt{-1}]$がPIDであるという性質から、$P+Q\sqrt{-1}$と$P-Q\sqrt{-1}$の最大公約数を$\gamma$と置くと、このイデアルは$\gamma$によって生成される単項イデアル$(\gamma)$です。よって、$\gamma | X_i+Y_i\sqrt{-1}$かどうかの判定を行うことで、この問題が解けました。

 また、以下の問題を考えてみましょう。
 \begin{itembox}[l]{問題}
  $N$個の非負整数$A_i$が黒板に書かれている。
  以下の操作を何度でも行える:
  \begin{itemize}
   \item 黒板にある数を一つ選び、それを$x$とする。$2x$を新しく書き込む。
   \item 黒板にある数を二つ選び、それらを$x,y$とする(同じ数でも良い)。$x \mathbin{\mathrm{xor}} y$ を新しく書き込む。
  \end{itemize}
  最終的に書き込める数のうち、$X$以下のものは何種類あるか? 998244353で割った余りを求めよ。

  (出典: ARC084 F - XorShift)
 \end{itembox}
 まず、演算が2倍とxorなので、整数を以下のようにして、$\finiteField{2}[x]$ の元
 (つまり、$\finiteField{2}$ 係数の多項式) として表すという発想が自然です:
 \begin{displaymath}
  t = b_u 2^u + b_{u-1}2^{u-1} + \cdots + b_1 2 + b_0 \mapsto
  b_u x^u + b_{u-1} x^{u-1} + \cdots b_1 x + b_0
 \end{displaymath}
 多項式の上の演算として考えると、2倍する操作は$x$をかける操作、xorをとる操作は多項式の足し算です。 ($\finiteField{2}$ の上の足し算がxorであることに注意してください。)
 $\finiteField{2}[x]$ はPIDなので、この問題は、$\finiteField{2}[x]$の上の最大公約数が計算できれば解けます。
 つまり、整数$t$が黒板に書き込めることと、以下が同値です:
 \begin{displaymath}
  t \in (A_1, \ldots, A_N) = (\gcd(A_1, \ldots, A_N))
 \end{displaymath}
 この場合、最大公約数の計算一回には$O(|A_i|^2)$時間かかるので、全体の計算量は$O(N|A_i|^2)$となり、十分間に合います。ビット並列のテクニックを使うことで、$O(N|A_i|^2/64)$にしても良いでしょう。

 ソースコードは以下のようになります。\url{https://arc084.contest.atcoder.jp/submissions/2137652} です。
 \lstinputlisting[caption=ARC084F.cpp,label=ARC084F.cpp]{ARC084F.cpp}
\printindex
\bibliographystyle{jplain}
\bibliography{./references}
\end{document}
